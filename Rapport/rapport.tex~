\documentclass[a4paper,11pt,danish,oneside]{article}

\usepackage[utf8]{inputenc}

\usepackage[danish]{babel}

\usepackage{graphicx}

\usepackage{multicol}

\usepackage[T1]{fontenc}

\usepackage[top=3cm, bottom=3cm, left=2.5cm, right=3.5cm]{geometry}

\usepackage{tocvsec2}

\usepackage{float}

\usepackage{tabularx}

\usepackage{parskip}

\usepackage{mathtools}

\usepackage{changepage}

\usepackage{mdwlist}

\usepackage{algorithm}

\usepackage{titlesec}

\usepackage{algpseudocode}

\algrenewcommand\algorithmicprocedure{\textbf{function}}

\usepackage[nottoc,numbib]{tocbibind}

\usepackage{setspace}

\linespread{1.4}

\titlespacing*{\section}{0pt}{0.5cm}{0cm}
\titlespacing*{\subsection}{0pt}{0.3cm}{0cm}
\titlespacing*{\subsubsection}{0pt}{0.1cm}{0cm}
\titlespacing*{\paragraph}{0pt}{0cm}{0cm}

\graphicspath{ {./Billeder/} }
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\begin{document}
\begin{titlepage}
	\setstretch{1}
\begin{center}
\textsc{\LARGE Syddansk Universitet}\\[1.5cm]

\textsc{\Large 3. Semester Projekt}\\[0.5cm]

\textsc{\large Robotteknologi Efteråret 2014}\\[0.5cm]
% Title
\rule{\linewidth}{0.5mm}\\[0.4cm]
{ \huge \bfseries DTMF kommunikation\\[0.4cm]}
\rule{\linewidth}{0.5mm}\\[1.2cm]

% Author and supervisor
\textbf{Gruppe 3}\\ \mbox{}\\ \mbox{}\\
\begin{tabular}{c c c}
	Martin Staal Steenberg & & Frederik Haarslev\\
	280694 & & 100694\\
	mstee13@student.sdu.dk & & frhaa13@student.sdu.dk\\
	\\
	\\
	\cline{1-1}\cline{3-3} \\
	Niels Alexander Hvid & & Nikolaj Westphal Leth \\
	120293 & & 200693 \\
	nhvid13@student.sdu.dk & & nilet13@student.sdu.dk\\
	\\
	\\
	\cline{1-1}\cline{3-3} \\
	Rasmus Karnøe Stagsted & & Theis Strøm-Hansen\\
	240394 && 270792 \\
	rasta13@student.sdu.dk && thstr13@student.sdu.dk\\
	\\
	\\
	\cline{1-1}\cline{3-3} \\
	Stefan Ravn van Overeem & &\\
	290394 & &\\
	stvan13@student.sdu.dk & &\\
	\\
	\\
	\cline{1-1}
	
\end{tabular}


\vfill

\textbf{Vejleder:} Ib Refer\\ \mbox{}\\
% Bottom of the page
\textbf{Projekt periode:} 22. september 2014 - {\large \today}
\end{center}
\end{titlepage}

\section*{Forord}
Vi vil gerne takke vores vejleder, Ib Refer, for at have stået til rådighed og for vejledning gennem hele projektforløbet. 

Den primære arbejdsfordeling har været som følger:
\begin{itemize}
	\item Frederik, Niels og Nikolaj har stået for det fysiske lag.
	\item Martin og Stefan har stået for datalinklaget.
	\item Rasmus og Theis har stået for applikationslaget.
	\item Frederik, Niels og Nikolaj har stået for den grafiske brugerflade.
	\item Nikolaj og Stefan har været de primære aktører i udførelsen af de praktiske tests.
	\item Hele gruppen har været involveret i skrivning af rapporten.
\end{itemize}

\newpage

{
	\setstretch{1}
\tableofcontents
}

\newpage

\section{Indledning}

Datakommunikation er disciplinen at udveksle data mellem to eller flere enheder. Datakommunikation er en væsentlig del af vores hverdag, og benyttes i store dele af vores daglige aktiviteter, såsom at surfe på internettet, sende sms’er, ringe til familien eller uploade og downloade data. Normalt benyttes disse tjenester uden, at der tænkes nærmere over, hvad der ligger bag. Realiteten er, at mange forskellige protokoller og teknologier er i spil for, at disse tjenester, kan fungere.

Datakommunikation kan i mange tilfælde ikke fungere alene, og der er ofte brug for signalbehandling til at behandle de signaler, der bærer dataen.

I dette projekt arbejdes der med kommunikation vha. lyd.
Målet med projektet er, at udvikle en applikation som, ved hjælp af forskellige kommunikationsprotokoller, kan få to eller flere enheder til at kommunikere med DTMF\footnote{Se ordliste.} toner. Applikationen skal skrives i C++, og skal opbygges som en lagdelt arkitektur. Der skal hertil inkorporeres forskellige elementer fra digital signalbehandling for bl.a. at fjerne støj. Der er til projektet blevet udleveret to \textit{Logitech Stereo Speakers Z120} og to \textit{Logitech Analog Desktop Microphones}.

Projektet endte ud med en point-to-point filoverførselsapplikation, som er i stand til at:

{\setstretch{1}
\begin{itemize}
	\item Oprette forbindelse mellem to enheder.
	\item Sende eller anmode om filer.
	\item Udfører fejlkontrol på sendte filer.
\end{itemize}
}

Ydermere er der designet en grafisk brugerflade til applikationen.

Denne rapport indeholder en detaljeret gennemgang, af den udviklede applikation, og de valg der er foretaget i løbet af projektperioden.

\section{Projektafgrænsning}
Der udvikles en filoverførselsapplikation, som skal være i stand til at sende og modtage filer mellem to enheder. Fokus vil ligge på at gøre protokollen robust og pålidelig, frem for hurtig, for at sikre, at den overførte data er fejlfri.

Der blev foretaget afgrænsende tests, se [B2]. Ved brug af flere højtalere kan det medføre negativ interferens, hvis højtalerne står forkert i forhold til hinanden. Af denne årsag er der valgt kun at bruge én højtaler, som placeres tæt på mikrofonen.

Produktet opbygges som en lagdelt softwarearkitektur. Med udgangspunkt i OSI modellen udvælges der tre af de følgende syv lag. Hertil tilstræbes det at have lav kobling mellem lagene.

\begin{description}
	\setstretch{1}
	\item [Applikationslaget]\hfill \\  Medtages da applikationen skal sende/modtage data. 
	\item [Præsentationslaget]\hfill \\  Fravælges idet applikationen skrives specifikt til protokollen.
	\item [Sessionslaget]\hfill \\ Fravælges da der ikke anvendes TCP.
	\item [Transportlaget]\hfill \\ Fravælges da kun en applikation bruger protokollen, så portnumre er irrelevante.
	\item [Netværkslaget]\hfill \\ Fravælges da der kun arbejdes med node-til-node kommunikation.
	\item [Datalinklaget]\hfill \\ Medtages da datalinklaget er ansvarlig for node-til-node kommunikation
	\item [Det fysiske lag]\hfill \\ Medtages da der skal overføres data mellem enheder.
\end{description}

\section{Problemanalyse}
Der findes en række problemer, indenfor de valgte fokusområder, som skal tages stilling til for at kunne gennemføre projektet.

\begin{description}
	\setstretch{1}
	\item [Transmissionsmediet]\hfill \\ Flere enheder deles om et fælles transmissionsmedie, luften, hvilket betyder, at der kan ske en kollision, hvis mere end én enhed prøver at sende data på samme tid.
	\item [Frekvenser]\hfill \\ I projektet er det kun tilladt at bruge DTMF toner. Dette betyder, der kun er otte frekvenser tilgængelige.
	\item [Støj]\hfill \\ Hvis der kommer støj på en af de otte frekvenser, kan signalet blive forvrænget, hvilket kan medføre korrupte data.
	\item [Signalbehandling]\hfill \\ Der skal undersøges den optimale frekvensanalysemetode, til de signaler, der sendes.
	\item [Synkronisering]\hfill \\ Det er vigtigt at de to enheder, der kommunikerer med hinanden, er synkroniseret. Det vil sige, at modtagerenheden lytter efter toner på de rigtige tidspunkter. Hvis ikke, vil kommunikationen være langt mere sårbar overfor støj.
	\item [Fejl kontrol]\hfill \\ Da det er valgt, at protokollen skal være robust, skal der implementeres en metode til at detektere fejl og kassere fejlbehæftede og duplikerede pakker. Hvis ikke dette gøres vil der leveres forkert data til applikationslaget.
	\item [Længden af frames]\hfill \\ For at vide hvornår en frame starter og slutter, er det nødvendigt med nogle markører, der kan fortælle modtageren dette. Dette kan f.eks. gøres med felter, med oplysninger om hvor lang framen er, eller med flag i start og slutningen af en frame.
	\item [Applikationslaget]\hfill \\ Skal opdele den data, der skal sendes, i mindre pakker, før de leveres til datalinklaget. Endvidere skal applikationslaget sammensætte de pakker den modtager.
\end{description}

\section{Problemformulering}
\textit{Hvorledes kan en kommunikationsprotokol designes så to enheder kan udveksle data, ved brug af lyd, i form af DTMF?}

\subsection{Primære problemstillinger}

{\setstretch{1}
\begin{itemize}
	\item Hvorledes markeres start og slutning på et stykke data?
	\item Hvorledes kan kollision undgås når begge enheder benytter samme transmissionsmedie?
	\item Hvorledes frasorteres støj, sådan at kun de ønskede frekvenser er tilbage?
	\item Hvorledes kontrolleres den transmitterede data for fejl, sådan at al korrupt data bliver kasseret?
\end{itemize}
}
\subsection{Sekundere problemstillinger}
{\setstretch{1}
\begin{itemize}
	
	\item Hvorledes kan en grafisk brugerflade designes?
	\item Hvorledes kan data sendes mere effektivt?
\end{itemize}
}
\section{Løsningsforslag}
Problemformuleringen specificerer konkrete problemer, der skal løses i løbet af projektet, for at kunne udarbejde det ønskede produkt. Løsningsforslagene skal vægtes efter fordele og ulemper og udvælges til brug i produktet.

\subsection{Signalanalyse}
Idet dataen skal sendes via lyd, og skal virke i et støjfyldt miljø for at have nogen form for praktisk anvendelse, skal signalet behandles, så eventuel støj kan ignoreres.

\subsubsection{Fast Fourier Transform}
FFT\footnote{Se ordliste.} er en metode til at beregne DFT\footnote{Se ordliste.} hurtigt og for alle sinuskoefficienter i signalet (op til Nyquist frekvensen\footnote{Se ordliste.}). Det er en fællesbetegnelse for alle algoritmer, der beregner DFT i $O(N \log_2(N))$ tid\footnote{Se ordliste.} (for $N$ samples) i forhold til $O(N^2)$ tid, hvis DFT beregnes direkte. Derfor er FFT en betragteligt hurtigere metode til at beregne DFT, hvis man skal bruge koefficienterne for alle sinuserne i signalet.

\subsubsection{Goertzel Algoritmen}
Goertzel algoritmen kan benyttes til at beregne de enkelte DFT koefficienter. Algoritmen er mere effektiv end FFT, hvis mindre end $2 \log_2(N)$ DFT koefficienter skal beregnes \cite{goertzel}.

Goertzel algoritmen har form som et digitalt filter, og er en kaskade af et IIR-filter\footnote{Se ordliste.} og et FIR-filter\footnote{Se ordliste.}.
\begin{equation}
	s(n)=x(n)+2 \cos(2 \pi f) s(n-1)-s(n-2)
\end{equation}
\begin{equation}
	y(n) = s(n) - e^{-2 \pi i f} s(n-1)
\end{equation}
hvor $x(n)$ er indgangssignalet, $s(n)$ er en mellemsekvens og $y(n)$ er udgangssignalet.

\subsubsection{Fordele og ulemper}

\begin{table}[h]
	\begin{tabularx}{\textwidth}{|X|X|X|X|}
		\hline
		\multicolumn{2}{|l|}{\textbf{Goertzel}} & \multicolumn{2}{l|}{\textbf{FFT}} \\ \hline
	\textbf{Fordele} & \textbf{Ulemper} & \textbf{Fordele} & \textbf{Ulemper} \\ \hline
	Hurtig ved færre koefficienter & Langsom ved mange koefficienter & Hurtig ved mange koefficienter & Langsom ved få koefficienter \\ \hline
	Simpel implementering& & & Kompliceret implementering\\ \hline
	\end{tabularx}
	\caption{Fordele og ulemper ved Goertzel og FFT}
\end{table}

\subsection{Dupleks}
Da transmissionsmediet ikke understøtter, at mere end én enhed sender med samme frekvenser samtidig, er der tre mulige løsninger: 

{\setstretch{1}
\begin{enumerate}
	\item Lav protokollen fuld-dupleks 
	\item Lav protokollen halv-dupleks
	\item Lav protokollen simpleks
\end{enumerate}}

Laves protokollen fuld-dupleks kræver det at frekvenserne opdeles (FDMA\footnote{Se ordliste.}) så hver enhed får tildelt en gruppe af tonerne. Disse grupper må ikke have nogen overlappende frekvenser, da dette ville resultere i, at enhederne forstyrrer hinanden. Derfor får hver enhed 4 ud af de 16 DTMF toner, og hver tone repræsenterer derved to bit.

Benyttes halv-dupleks, er det ikke muligt, at begge enheder transmitterer på samme tid. Dog opnås at hver tone repræsentere fire bit.

Simpleks kasseres, da der ønskes at kunne sende data i begge retninger.

\subsection{Fejlkontrol}
Paritetscheck, CRC, SHA og MD5 er fire hyppigt brugte metoder til fejldetektion ved overførsler.

\subsubsection{Paritetsbit}
En paritetsbit angiver om der er et lige eller ulige antal 1’ere i en datapakke. Fordelen ved denne type fejlkontrol er, at størrelsen på fejlkontrollen kun er én bit. Ulempen er, at denne type fejlkontrol kun kan fange ulige antal fejl i overførslen. Hvis der et lige antal bit der er blevet vendt, så vil paritetschecket hos modtageren ikke opdage fejlene.

\subsubsection{Cyclic Redundancy Check}
CRC laver et antal redundante bit, der bliver påsat pakken, som skal overføres.  Fordelen ved CRC er, at der kan detekteres single-, dual- og burstfejl \cite[s. 264-267]{datakom}.

Størrelsen af CRC definerer hvor mange fejl, der kan detekteres ved kontrol. Ulempen ved CRC er, at jo større CRC’en er, jo flere redundante bit bliver der påsat datapakken \cite[s. 264-267]{datakom}.

\subsubsection{SHA og MD5}
Der eksistere utallige biblioteker, som indeholder checksum specifikt til validering af filer.

SHA er en checksum, der findes i mange forskellige størrelser og bliver brugt til sikker validering over internettet. En anden checksum er md5sum, som ikke længere bliver betragtet som sikker mod angreb, men er næsten dobbelt så hurtig som en af de laveste SHA\footnote{MD5 6.8 Cycles/Byte, SHA1 11.4 Cycles/Byte \cite{cryptopp}}. Risikoen for, at to stykker data giver samme md5sum er $1:2^{128}$ \cite{cryptopp}.

\subsection{Datalinklagsprotokol}
Tre protokoller bliver taget i betragtning: Stop-and-Wait, Go-Back-N og Selective-Repeat.

\subsubsection{Stop-and-Wait}
Stop-and-Wait protokollen benytter halv-dupleks, og inkorporerer både flow- og fejlkontrol. Se figur 1. Fejlkontrol sker i form af en checksum, som bruges til at validere data, mens flowkontrollen foregår ved at pakken først sendes når forrige pakke er blevet kvitteret for.

Protokollen fungerer således at der sendes én pakke ad gangen, hvorefter der ventes på ACK\footnote{Se ordliste.}. Når pakken sendes startes en timer, som bruges til at gensende pakken, hvis afsenderen ikke har modtaget en ACK inden for et givent tidsrum.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{stop-and-wait}
	\caption{Princippet bag Stop-and-Wait. Taget fra \cite[s. 301-304]{datakom}. Modificeret.}
\end{figure}

\subsubsection{Go-back-N}
Go-Back-N protokollen benytter fuld-dupleks. Se figur 2.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{go-back-n}
	\caption{Princippet bag Go-Back-N. Taget fra \cite[s. 713-720]{datakom}}
\end{figure}

Protokollen fungerer ved, at der sendes en række pakker i et såkaldt “vindue”. Modtageren sender en ACK med et ACK nummer, når en pakke er modtaget korrekt. ACK nummeret fortæller afsenderen, hvilken pakke der forventes næste gang, og vinduet rykkes. Dette betyder, at en ACK kan gå tabt, uden det påvirker det øvrige flow, idet en senere ACK kvittere for alle forrige pakker. Der kører en timer for den ældste udestående pakke, og hvis timeren udløber gensendes alle pakkerne i vinduet.

\subsubsection{Selective-Repeat}
Selective-Repeat protokollen benytter fuld-dupleks. Se figur 3.

Protokollen baserer sig ligesom Go-Back-N på vinduer. Der sendes en ACK med et ACK nummer, for hver pakke der bliver modtaget. Dette nummer korresponderer med en datapakke, og betyder, at den specifikke pakke er blevet modtaget korrekt. Afsenderen har en timer for hver pakke i vinduet, og hvis den udløber, gensendes kun den enkelte pakke.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{selective-repeat}
	\caption{Princippet bag Selective-Repeat. Taget fra \cite[s. 720-726]{datakom}. Modificeret.}
\end{figure}

\subsection{Start og slutning på data}
For at fortælle modtageren hvornår en frame starter og slutter, skal der benyttes nogle markører. Der findes to almindelige metoder til at gøre dette:

\subsubsection{Start- og slutflag}
I starten af framen kan der placeres et flag, det vil sige en bestemt rækkefølge af bit. Dette flag markerer starten af en frame. Samtidig kan der ved framens slutning placeres et flag, der markerer at framen slutter.

\subsubsection{Længdefelt}
I framens header kan der laves et felt, der beskriver hvor lang framen er. Dermed ved modtageren, at framen er slut, når der er modtaget den mængde data, der er beskrevet i feltet.

Der er fordele og ulemper ved de forskellige metoder. Hvis et slutflag benyttes er det nødvendigt at anvende bitstuffing for at undgå at flaget optræder i dataen. Til gengæld er denne metode lettere at implementere på det fysiske lag, da laget ikke skal læse i datalinklagets header.

\section{Valg af løsning}
Der skal vælges hvilke løsninger, på ovenstående problemstillinger, der implementeres.
Der skal bruges en metode til signalanalyse. Her vælges Goertzel algoritmen.
Denne vælges da amplituden kun skal bruges ved otte forskellige frekvenser. Derfor vil det være hurtigere at benytte Goertzel hvis der arbejdes på mere end $n=2^{x/2}=2^{8/2}=16$ samples.

Det skal vælges, om der skal benyttes halv- eller fuld-dupleks.
Fuld-dupleks er optimalt hvis der f.eks. ønskes at lave en chat applikation, da begge enheder ville være istand til at sende deres beskeder uden at vente på hinanden. Men da der ønskes at lave en filoverførselsapplikation, hvor den ene enhed skal sende mere data end den anden, er det blevet valgt at halv-dupleks skal benyttes, da det vurderes, at der dermed kan opnås den højeste overførselshastighed.

Det skal sikres at der ikke slipper korrupte datapakker igennem til applikationslaget. 

Til fejlkontrol vælges der to forskellige metoder. CRC på datalinklaget, og en md5sum på applikationslaget. På datalinklaget vælges der CRC grundet mængden af fejl CRC kan detektere. md5summen vælges på applikationslaget for at have en ekstra kontrol hvis det skulle ske at en fejl kommer igennem på datalinklaget. 

Til at markere starten og slutningen af en pakke vælges der et start- og slutflag, da det gør det fysiske lag simplere.

Det sidste der skal besluttes, er hvilken protokol der skal bruges til overførslen. Baseret på det foregående valg, med at benytte halv-dupleks, er det kun Stop-and-Wait protokollen der er tilbage. Derfor er denne valgt.

\section{Produkt}
Ud fra ovenstående valg, bliver produktet halv-dupleks, med en Stop-and-Wait-baseret protokol. For at sikre imod korrupt data, er der samtidig valgt fejlkontrol på både datalink- og applikationslaget.

Der er udviklet tre lag til produktet: 

{\setstretch{1}
\begin{enumerate}
	\item Et fysisk lag der står for kommunikationen mellem to enheder (ikke pålideligt\footnote{Se ordliste.}).
	\item Et datalinklag der står for nummerering af pakkerne, håndtering af forbindelsen samt
	fejlkontrol (pålideligt).
	\item Et applikationslag der står for håndteringen af filoverførslen og funktionalitet, der benyttes. 
\end{enumerate}}

Programmet er opbygget således, at hvert lag er en klasse\footnote{Se ordliste.} for sig selv. I hver klasse kører der nogle tråde\footnote{Se ordliste.}, der tager sig af indgående og udgående data på de forskellige lag. Opbygningen i tråde gør det muligt at undgå, at de forskellige lag blokerer for hinanden, og de kan derfor arbejde uden at vente på hinanden. Kommunikationen mellem de forskellige lag foregår ved hjælp af buffere. Se figur 4.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.2]{Lagdelt}
	\caption{Programmets lagdelingsstruktur}
\end{figure}

Lagene er opbygget i klasser, da det gør det lettere at isolere funktionaliteten i de forskellige lag i separate komponenter, der kan udvikles og fejlrettes individuelt og uafhængigt af hinanden. Samtidig betyder det, at det er let at udskifte et lag med et andet.

\newpage
Datalinklaget og det fysiske lag har følgende offentlige metoder, der benyttes af de øvre lag:

\begin{table}[h]
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		\textbf{Fysiske lag} & \textbf{Forklaring}\\ \hline
		bool dataAvailable() & Er der nye frames til datalinklaget?\\ \hline
		bool layerBusy() & Er bufferen fuld?\\ \hline
		vector<bool> popData() & Hent en frame fra det fysiske lag\\ \hline
		void pushData(vector<bool>) & Levér en frame til det fysiske lag\\ \hline
	\end{tabularx}
	\newline \newline \newline
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		\textbf{Datalinklaget} & \textbf{Forklaring}\\ \hline
		bool dataAvailable() & Er der nye pakker til applikationslaget?\\ \hline
		int dataBufferSize() & Hvor mange pakker er der i kø?\\ \hline
		bool dataBufferSize() & Er bufferen fuld?\\ \hline
		vector<bool> popData() & Hent en pakke fra datalinklaget\\ \hline
		void pushData(vector<bool>) & Levér en pakke til datalinklaget\\ \hline
	\end{tabularx}
	\caption{Det fysiske lag og datalinklagets offentlige metoder}
\end{table}

\subsection{Format}
Hvert lag tilføjer sin egen header og trailer. Det komplette format kan ses på figur 5.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{framestructure}
	\caption{Produktets komplette frame format.}
\end{figure}

\subsection{Biblioteker}
Programmet er skrevet i C++11 og benytter følgende softwarebiblioteker:

\begin{description}
	\setstretch{1}
	\item [Portaudio]\hfill \\ Til at optage lyd
	\item [SDL2]\hfill \\ Til at afspille lyd
	\item [Boost]\hfill \\ Til forskellige filsystem operationer, fx. læsning af mappestrukturer.
	\item [Crypto++]\hfill \\ Til at beregne md5sum.
	\item [bzip2]\hfill \\ Komprimering
	\item [readline]\hfill \\ Til auto-completion i command-line interfacet.
	\item [QT5]\hfill \\ Til grafisk brugerflade.
\end{description}

\subsection{Det fysiske lag}

Det fysiske lag har til hovedansvar at konvertere bit til DTMF toner og sende dem. Det fysiske lag står også for at opfange DTMF toner, og konvertere dem til bit. Disse to funktioner kører i hver sin tråd, som herfra bliver refereret til som sender- og modtagertråden.

\subsubsection{Sendertråden}

Når datalinklaget levere frames ned til det fysiske lag, sker følgende:

{\setstretch{1}
\begin{itemize}
	\item Nibbles\footnote{Se ordliste.} konverteres til en tilsvarende DTMF tone.
	\item Start- og slutflag tilføjes.
	\item Der tilføjes en synkroniseringssekvens.
\end{itemize}}

Hvad synkroniseringssekvensen, samt start- og slutflag bruges til, forklares i afsnit [7.1.2] om modtagertråden.

Til at sende den endelige sekvens af DTMF toner, benyttes en afspillerklasse.

\paragraph{Afspiller}\mbox{}\\
Afspilleren anvender lydbibliotektet SDL2 Audio \cite{sdl}, som er en del af SDL. Dette bibliotek er valgt, da det tillader at genere samples, som lægges i output bufferen, frem for kun at afspille færdige lydfiler. Biblioteket har også den fordel at det er et multiplatformsbibliotek, så den samme kode kan anvendes på forskellige versioner af Windows og Linux. Samtidig foreligger der god dokumentation til biblioteket, med mange eksempler på brug af funktionerne. Dertil er biblioteksserien SDL meget anvendt, også hos professionelle aktører. SDL Audio gør brug af en brugerdefineret callback funktion\footnote{Se ordliste.}, som køres i en seperat tråd, sammen med afspilning af lyden.

Afspilleren initialiseres med en samplerate på 4000 Hz da dette overholder Nyquistligningen, samtidig med at det har vist gode resultater i testene, se [B3]. Ligeledes sættes en buffer størrelse på 1024 samples og med fade ind/ud på 3 samples (10 samples er bedst ifølge [B3], mens senere test i [B4] krævede at den blev sat ned til 3).

\newpage
Disse indstillinger er sat som foretrukne indstillinger, og SDL vil så vidt muligt anvende disse. Det kan ske at hardwaren ikke understøtter de foretrukne indstillinger. SDL vil i dette tilfælde automatisk prøve at justere indstillingerne, eller konvertere lyden hvis det foretrukne lydformat ikke understøttes. Der kan derfor forekomme mindre forskelle i signalet, på forskelligt hardware. SDL er sat til at melde hvis lyden ikke kan afspilles uden at justere indstillingerne.

\paragraph{Afspilning af lyd}\mbox{}\\
Når der skal afspilles lyd, dvs. sendes en frame, kaldes funktionen PlayDTMF() med en vector\footnote{Se ordliste.} med de toner, der skal afspilles, en tonelængde og en pauselængde som argumenter. Funktionen opsætter de mest gense indstillinger for afspilningen; antallet af toner, tonelængde i samples og pauselængde i samples; hvorefter den starter lyden, så callback() aktiveres, og lyden afspilles. Efterfølgende venter funktionen indtil alle toner er lagt i lyd bufferen, hvorefter den pauser lyden igen, og returnerer.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{Fysiske_lag/player_callback_function}
	\caption{Callback funktion der står for generering af samples til afspilleren}
\end{figure}

Afspilningen og genereringen af lyden foregår i etaper, og starter med, at callback() kaldes. Se figur 6. Denne sætter indstillinger op til den første tone der skal afspilles, hvorefter den generere samples, som lægges ned i lydbufferen. Når bufferen er fyldt, begynder lyden at blive afspillet, mens callback() sørger for at fylde bufferen igen. Således er den klar igen når de første samples er færdig med at blive afspillet. Dette kører i ring, indtil den første tone er færdig med at blive afspillet, hvorefter indstillingerne ændres til at være en pause (dvs. samples får værdien 0). Når der er fyldt det rigtige antal samples med værdien 0 ned i bufferen, svarende til den tid der ønskes pause, ændres indstillingerne til den næste tone i rækken. Dette fortsætter indtil alle toner er afspillet: tone $\rightarrow$ pause $\rightarrow$ tone $\rightarrow$ pause osv.

Som en ekstra feature er der tilføjet fade ind og ud på hver tone, for at få bedre lydkvalitet. Dette opnås ved, at callback() fader de første 3 samples ind: $\frac{1}{3} \ amplitude$, $\frac{2}{3} \ amplitude$ og $\frac{3}{3} \ amplitude$, og ligeledes fades de sidste 3 samples af hver tone ud.

Grundet opbygningen af bufferen, skal denne altid fyldes helt, dvs., at callback() ikke må afsluttes, før bufferen er helt fyldt, samtidig med, at bufferen ikke må overfyldes. Dette betyder, at en tone godt kan spredes ud over flere opfyldninger af bufferen. Omvendt kan én buffer også indeholde flere toner og pauser. callback() skal derfor holde styr på, at indstillingerne skiftes mellem pause og tone, både hvis det skal ske flere gange mens bufferen fyldes én gang, eller hvis de er spredt ud over flere opfyldninger. Funktionen sikre at tonerne og pauserne får den helt korrekte længde, samtidig med at lydenhederne ikke går ned, grundet forkert data.

Når der ikke er flere toner tilbage der skal afspilles, sørger callback() for at fylde resten af bufferen, og efterfølgende buffere, med 0, indtil lyden bliver pauset. 

Grundet kodens opbygning skal der være en pause mellem hver tone. Koden er testet og har vist sig stabil ned til en tonelængde på 25 ms og en pause længe på 2 ms. Kortere tonelængder er også mulige, men giver problemer andre steder i programmet [B4,B5].

\subsubsection{Modtagertråden}

Det første det fysiske lag lytter efter når den skal opfange en frame er synkroniseringssekvensen. Se figur 7. Når synkroniseringssekvensen er opfanget korrekt, sker følgende:

{\setstretch{1}
\begin{itemize}
	\item Der lyttes efter startflaget.
	\item Der lyttes efter slutflaget, og alle forrige toner gemmes.
	\item De opfangede DTMF toner konverteres til bit.
\end{itemize}}

Til at lytte efter tonerne, benyttes en optagerklasse.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{Fysiske_lag/physicallayer_getthreads}
	\caption{Flowchart over modtagertråden på det fysiske lag}
\end{figure}

\paragraph{Filtrering af støj og detektion af DTMF toner}\mbox{}\\
Hos modtageren er det nødvendigt at detektere hvilken af de 16 DTMF toner afsenderen har sendt.  Dette gøres ved at behandle de optagne samples med Goertzelalgoritmen, og dermed få amplituden på de otte frekvenser, som DTMF består af.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.16]{dtmf}
	\caption{DTMF tonernes frekvenser}
\end{figure}
DTMF frekvenserne består af to grupper, fire høje frekvenser og fire lave. En frekvens fra hver af disse to grupper kombineres, og de 16 DTMF toner kan dermed skabes. Se figur 8. For at finde ud af hvilken af tonerne, de optagne samples repræsenterer, findes den frekvens i hver gruppe, der har højest amplitude. Den tone, som kombinationen af disse frekvenser udgør er den tone, der er blevet optaget.

\paragraph{Optager}\mbox{}\\
Til optageren havde det været mest hensigtsmæssigt at vælge det samme lydbibliotek som til afspilleren, men da SDL2 audio biblioteket ikke indeholder en optagerfunktion, måtte et andet bibliotek vælges. Dette blev PortAudio \cite{portaudio}, da det ligesom SDL er et open-source, multiplatformsbibliotek, som gør brug af en callback funktion. Grundet dette kunne der skrives en optager, som kan afvikles på forskellige versioner af både Linux og Windows. Derudover foreligger der god dokumentation til biblioteket, samt flere eksempler der illustrere brugen af de forskellige funktioner.

Optageren indeholder to dele; optagerdelen og metodekaldet der giver mulighed for at få fat i de optagne samples.

Optagerdelen sættes i gang, så snart optager objektet oprettes, og fungerer ved at optageren initialiseres med en samplerate på 24000 Hz og en buffer størrelse på 8 samples. Sampleraten på 24000 Hz er valgt på baggrund af tests [B4], hvor denne samplerate gav færrest fejl. En lille bufferstørrelse giver hurtig adgang til de nyoptagne samples.

Når indstillingerne er sat, kører optagerdelen konstant, indtil programmet lukkes. For hver gang der er optaget 8 samples, kaldes optagerens callback funktion, som overfører de 8 samples til en ringbuffer, som kan tilgås af resten af det fysiske lag. Denne ringbuffer kan indeholde 882.000 samples, svarende til ca. 37 sekunders optagelse. Når bufferen er fyldt, overskrives de ældste samples med de nyeste. Ringbufferen er placeret på heapen\footnote{Se ordliste.}, så den ikke fylder stacken\footnote{Se ordliste.} op, og styres ved hjælp af en pointer\footnote{Se ordliste.}, som kører rundt i bufferen. Se figur 9.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{Fysiske_lag/recorder_get_samples}
	\caption{GetAudioData’s hentning af samples fra ringbuffer}
\end{figure}

Til at hente samples ud fra ringbufferen, anvendes funktionen GetAudioData(), der kan ses på figur 7. GetAudioData() kræver en varighed og et offset som argumenter, og returnerer en vektor med samplesne. For at flytte samplesne fra bufferen over til vektoren, anvendes en anden pointer. Denne pointer bliver oprettet med værdien fra ringbufferens pointer, hvorefter den justeres en afstand tilbage:
\begin{equation}
	pointer = \textit{Ringbuffer pointer} - (varighed+\textit{offset})\cdot samplerate
\end{equation}
\newpage
Efter pointeren er justeret den korrekte afstand tilbage, kopieres samplesne ud fra bufferen over i vektoren enkeltvis. Se figur 9.

På denne måde kan der hentes samples ud af ringbufferen, mens optageren fortsætter med at optage uforstyrret.

\paragraph{Synkronisering}\mbox{}\\
Modtagertråden består af en synkroniserings-, startflags- og dataløkke, som eksekveres skiftevis mens programmet kører. Formålet med synkroniseringsløkken er, at modtageren skal sample i samme periode som afsenderen afspiller tonen i.

Synkroniseringen mellem modtageren og afsenderen etableres ved konstant at hente samples svarende til en tonelængde. Disse behandles med Goertzel algoritmen for at finde den DTMF tone, som passer med de optagne samples. Når der konstant hentes samples, vil samme DTMF tone kunne detekteres flere gange. Da synkroniseringssekvensen ikke indeholder to ens DTMF toner efter hinanden, vil flere målinger af samme DTMF tone betyde, at den samme tone er målt to gange. Dermed er det altså den samme tone, der er blevet målt, og ikke to separate. Synkroniseringen opnås ved at sample indtil en ny tone er optaget. Med antagelsen at samplingen foregår hurtigt nok til at samme tone samples mange gange, vil det betyde, at de samples der giver en ny tone, er påbegyndt midt i den forrige tone, se figur 12. Halvdelen af tonelængden og pausen mellem hver tone trækkes fra starten af samplen for at finde starten af en tone. Dette gemmes som et tidsanker, der bruges til at beregne starten for fremtidige toner.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{Fysiske_lag/Tegning1}\\
	\includegraphics[scale=0.3]{Fysiske_lag/Graf1}\\
	\caption{Samples der kun rammer en tone.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{Fysiske_lag/Tegning2}\\
	\includegraphics[scale=0.3]{Fysiske_lag/Graf2}\\
	\caption{Samples der indeholder to toner. Den højeste tone er den samme som den forrige.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{Fysiske_lag/Tegning3}\\
	\includegraphics[scale=0.3]{Fysiske_lag/Graf3}\\
	\caption{Samples rammer stadig to toner, men nu er det en ny tone der har størst amplitude. Starten på en sample udregnes ved at trække en halv tonelængde og en halv pause fra.}
\end{figure}

Synkroniseringsløkken eksekveres indtil de sidste tre optagne toner svarer til synkroniseringssekvensen. Når dette sker, gemmes tiden for den sidste samplede tone, og denne bruges som tidsanker, så startflags- og dataløkken ved hvornår der skal samples efter toner.

\subsection{Datalinklaget}
Datalinklagets ansvar ligger i: oprettelse og nedlægningen af forbindelsen, kassering af duplikerede pakker, bitstuffing, padding og fejl kontrol. Datalinklaget er opdelt i to tråde: en til at sende data og en til at modtage data.

For at datalinklaget kan fungere, er der to fundamentale regler, som skal etableres.
{\setstretch{1}
\begin{itemize}
	\item Kun én enhed må sende data ad gangen.
	\item Kun én enhed har lov til at benytte mediet ad gangen.
\end{itemize}}
For at disse regler kan overholdes bliver hver enhed som deltager i kommunikationen nødt til at vide, om den har lov til at sende eller modtage data. Dette gøres ved at lave protokollen forbindelsesorienteret.
Hver enhed kan have én af tre forskellige tilstande: \textit{idle}, \textit{client} eller \textit{server}.

\newpage
Når enheden er \textit{idle}, er der ikke oprettet nogen forbindelse. Dermed har den lov til at prøve at oprette en forbindelse, hvis den har data den ønsker at sende, og acceptere en forbindelsesanmodning. Der må ikke sendes data i \textit{idle}.

Når enheden er \textit{client}, har den anden enhed initialiseret en forbindelse. Mens enheden er \textit{client} må den kun modtage data, sende ACK og acceptere en nedlæggelse af forbindelsen.

Når enheden er \textit{server}, har den initialiseret en forbindelse, og har lov til at sende data og nedlægge forbindelsen.

Systemet er opbygget efter først til mølle princippet: Den der først anmoder om en forbindelse bliver \textit{server}. Det er ikke muligt for klienten at nægte oprettelse af forbindelse, eller data.

\subsubsection{Format}
Datalinklagets header er bygget op i et antal felter, som det ses på figur 13

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{Datalinklaget/datalinklayer_framestructure}
	\caption{Datalinklagets frameformat.}
\end{figure}

\paragraph{Kontrol af ID}\mbox{}\\
Hvis en ACK går tabt, bliver serveren nødt til at sende pakken igen, da det antages, at pakken er gået tabt. Dette giver dog et problem, da pakken på klientsiden allerede er leveret til applikationslaget. Den dublerede pakke, bliver nødt til at blive sorteret fra, så applikationslaget ikke modtager den samme pakke to gange.

For at løse dette problem benyttes pakke ID. Hver pakke har sit eget ID og hvis klienten modtager to pakker med samme ID i træk, vil den anden pakke blive kasseret og en ny ACK sendes til serveren. Dette er kun nødvendigt på pakker, der indeholder data, som skal leveres til applikationslaget. Alle andre pakketyper er administrativ data, til datalinklaget.

\begin{description}
	\setstretch{1}
	\item [\textit{Implementering}]\hfill \\
	På datalinklaget benyttes Stop-and-Wait protokollen, hvilket betyder, at der aldrig kommer til at være mere end én udestående pakke. Derfor er det valgt kun at benytte et én bit ID felt.
	
	\item [\textit{Serveren}]\hfill \\
	Hver gang en ny pakke bliver taget ud af bufferen fra applikations laget, bliver ID feltet inverteret.
	
	\item [\textit{Klienten}]\hfill \\
	Hvis datapakken har samme ID som den forrige bliver den bortkastet. Hvis ikke kan dataen leveres videre.
\end{description}

\paragraph{Type}\mbox{}\\
Datalinklaget benytter et typefelt på tre bit til at udføre forskellige operationer. 
Der er fem forskellige typer.

\begin{table}[h]
	\centering
	\begin{tabular}{|l|c|}
		\hline
		\textbf{Type} & \textbf{Bit repræsentation}\\ \hline
		Data & 000\\ \hline
		Acknowledge & 001\\ \hline
		Request & 010\\ \hline
		Accept & 011\\ \hline
		Terminate & 100\\ \hline
	\end{tabular}
	\caption{Typerne på datalinklaget}
\end{table}

\begin{description}
	\setstretch{1}
	\item [\textit{Data}]\hfill \\
	Denne type fortæller klienten, at pakken indeholder data, som skal leveres til applikationslaget.
	
	\item [\textit{Acknowledge}]\hfill \\
	ACK benyttes af klienten til at fortælle serveren, at den har modtaget pakken uden fejl.
	
	\item [\textit{Request}]\hfill \\
	Request benyttes til at anmode om at oprette en forbindelse.
	
	\item [\textit{Accept}]\hfill \\
	Accept benyttes af klienten til både at acceptere oprettelsen og nedlægningen af forbindelsen.
	
	\item [\textit{Terminate}]\hfill \\
	Terminate benyttes af serveren til at nedlægge forbindelsen.
\end{description}

\paragraph{Padding}\mbox{}\\
Hver tone er fire bit, hvilket betyder, at al data der skal sendes, skal gå op i fire. Hvis pakken, der skal leveres til det fysiske lag, ikke lever op til dette krav, er det nødvendigt at tilføje ekstra bit bag dataen. Disse bit kaldes for padding og er 1’er.

\paragraph{Padding Length}\mbox{}\\
Et felt på to bit tilføjes for at klienten ved hvor hvor meget padding der er på pakken

\paragraph{Cyclic Redundancy Check}\mbox{}\\
Til projektet ønskes der en pålidelig protokol, derfor benyttes CRC.
Fejlkontrollen bliver lavet på dataen, der ankommer fra modparten, og bruges til at undersøge om der er fejl i dataen.

\newpage
Til projektet bruges der CRC-32, da det viste sig, at en mindre CRC ikke fangede nok fejl.

Når dataen skal overføres, skal den igennem en CRC-enkoder. Denne enkoder skal generere de redundante bit, som påsættes dataen.

\begin{algorithm}[h]
	\begin{algorithmic}[1]
		\Procedure{CRCencoder}{dataword}
		\State divisor = {1,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,0,0,0,1,1,1,0,1,1,0,1,1,0,1,1,1}
		\State dividend = dataword
		\For{i from 0 to length of divisor - 1}
		\State append dividend with 0 
		\EndFor
		\For{i from 0 to length of dataword}
		\If{i'th element of dividend is 0}
		\For{j from 0 to length of divisor}
		\State set dividend i + j to dividend i + j \textbf{xor} with divisor j
		\EndFor
		\EndIf
		\EndFor
		\For{i from 0 to length of divisor - 1}
		\State append dataword with dividend i + length of dataword
		\EndFor
		\EndProcedure
	\end{algorithmic}
	\caption{Genererer redundante bit ud fra data.}
\end{algorithm}

Efter framen modtages, skal den dekodes. Til dette bliver næsten samme fremgangsmåde brugt. Er resultatet nul, er dataen ikke korrupt.

\paragraph{Bitstuffing}\mbox{}\\
På det fysiske lag benyttes et slutflag for at markere hvornår en frame slutter. Det er derfor vigtigt at framen ikke indeholder slutflaget. For at undgå dette benyttes bitstuffing.

Protokollens slutflag er defineret som 10101110. Bitstuffingen fungerer ved, at hele framen tjekkes for om de første syv bit af flaget forekommer i rækkefølge. I så fald vil der bliver indsat en bit med værdien 1 efter den syvende bit (da den sidste bit i flaget er 0).

Hos modtageren tjekkes framen, og hvis de syv første bit af flaget forekommer i rækkefølge, og den efterfølgende bit har værdien 1, bliver denne fjernet. Dermed vil framen hos modtageren være identisk med den oprindelige.

\subsubsection{Buffere mellem datalinklaget og applikationslaget}
Datalinklaget indeholder to bufferer, der benyttes til at kompensere for hastighedsforskellen mellem datalinklaget og applikationslaget.

Den første er en udgående buffer, som applikationslaget lægger data i, når der er noget at sende. Datalinklaget læser fra bufferen, når det er klar til at levere en ny frame. 

Den anden er en indgående buffer, som datalinklaget lægger data i, når det har modtaget og behandlet en frame fra det fysiske lag. Applikationslaget læser fra bufferen, når det er klar til at behandle en ny pakke.

Bufferne er ringbuffere -- dog anderledes end den på det fysiske lag. Ringbufferne er implementeret som en liste på en fast størrelse. Der er to pointere associeret med listen, kaldet \textit{head} og \textit{tail}. \textit{Tail} peger på den ældste data, der er blevet lagt i bufferen, mens \textit{head} peger på den nyeste. Se figur 14.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{Datalinklaget/Buffer}
	\caption{Illustration af en ringbuffer med head og tail pointerne.}
\end{figure}

Når der bliver lagt nyt data i bufferen rykkes \textit{head} en plads frem. Bliver der trukket data ud af bufferen rykkes \textit{tail} ligeledes en plads frem. Der er samtidig en tæller, som indeholder information om hvor mange læse og skrive operationer, der er blevet foretaget. Denne bruges til at holde styr på om bufferen er tom eller fuld.

Hovedårsagen til at en ringbuffer benyttes er, at den er threadsafe\footnote{Se ordliste.}. Applikationslaget og datalinklaget kører i to forskellige tråde, og det er derfor vigtigt, at der ikke opstår fejl i de tilfælde hvor begge lag forsøger at tilgå bufferen samtidig. Dette opnås ved, at det ene lag kun kan læse fra \textit{tail}, mens det andet lag kun kan skrive til \textit{head}. Dermed vil de to tråde aldrig tilgå det samme hukommelsesområde samtidig.

Bufferens størrelse er valgt arbitrært til at kunne indeholde 100 pakker.

\subsubsection{Funktioner}
Datalinklagets opgave er oprettelse og nedlægning af forbindelser, samt at sende pakker. Hertil er en række funktioner blevet implementeret.

\paragraph{sendPacket()}\mbox{}\\
Når en frame skal sendes, tilføjes datatypen og ID. CRC bruges til at generere de redundante bits som tilføjes. Til sidst bliver framen bitstuffet og padded. Hvis framen bliver sendt fem gange uden succes, nedlægges forbindelsen, da det antages at klienten er utilgængelig.

\begin{algorithm}[h]
	\caption{Forsøger at sende en pakke indtil der ankommer en ACK}
	\begin{algorithmic}[1]
		\Procedure{sendPacket}{}
		\While{packet not acknowledged}
		\If{packet has been sent 5 times unsuccessfully}
		\State connectionRelease()
		\State Break
		\EndIf
		\State send packet
		\State start timer
		\State wait until packet acknowledged or packet timed out
		\EndWhile
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\paragraph{connectionRequest()}\mbox{}\\
Hvis enheden har noget, der skal sendes, skal der oprettes en forbindelse. Dette gøres ved at sende en \textit{request}. Hvis ikke der modtages en \textit{accept} efter en \textit{request} er sendt tre gange, betyder det, at der enten er støj på mediet, eller at begge enheder forsøger at oprette forbindelse samtidig. Derfor træder enheden tilbage en tilfældig tid, for at undgå kollision ved næste \textit{request}.

\begin{algorithm}[h]
	\caption{Forespørger om at oprette en forbindelse.}
	\begin{algorithmic}[1]
		\Procedure{connectionRequest}{}
		\While{connection not accepted}
		\If{request has been sent 3 times unsuccessfully}
		\State sleep random time
		\EndIf
		\State send request
		\State start timer
		\State wait until request confirmed or request timed out
		\EndWhile
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\paragraph{connectionRelease()}\mbox{}\\
Når serveren ønsker at nedlægge forbindelsen, sender den en frame af typen \textit{terminate}. Hvis der ikke modtages en \textit{accept}, efter den har sendt forespørgslen tre gange, antages det, at klienten er utilgængelig og tilstanden sættes til idle.

\begin{algorithm}[h]
	\caption{Bruges til at nedlægge forbindelsen.}
	\begin{algorithmic}[1]
		\Procedure{connectionRelease}{}
		\While{release not accepted}
		\If{terminate has been sent 3 times}
		\State mode is set to idle
		\State Break
		\EndIf
		\State send terminate
		\State start timer
		\State  wait until release confirmed or terminate timed out
		\EndWhile
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\subsubsection{Sendertråden}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.45]{Datalinklaget/datalinklayer_transmitter}
	\caption{Flowchart over sendertråden på datalinklaget.}
\end{figure}
Sendertrådens opgave ligger i at oprette og nedlægge forbindelser, påsætning af datalinklagets header og trailer og levere frames til det fysiske lag. Se figur 15.

Tråden administrer hvornår disse opgaver må udføres og sørger for, at de to enheder ikke benytter transmissionsmediet på samme tid, samt at kun en af enhederne sender data ad gangen.

\subsubsection{Modtagertråden}
Modtagertrådens opgave ligger i at svare med \textit{accept} på oprettelse og nedlægning af forbindelser, udføre ID og fejlkontrol og sende ACK på korrekt modtagne frames. Når en frame modtages sørger tråden for at fjerne padding og bitstuffingen. Framen skal herefter behandles ud fra enhedens tilstand. Se figur 16.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{Datalinklaget/datalinklayer_receiver}
	\caption{Flowchart over modtagertråden på datalinklaget}
\end{figure}

Modtagertråden benytter en timer, til at time sig selv ud hvis den som \textit{client} ikke har hørt fra serveren i et stykke tid.

\subsection{Applikationslaget}
Applikationslaget implementerer filoverførselsfunktionaliteter, der gør det muligt at manipulere med, og sende, filer på forskellige måder. 

Der blev i starten af projektet udviklet en CLI\footnote{Se ordliste.} til applikationen. Der blev senere hen designet en GUI\footnote{Se ordliste.} der kunne benyttes i stedet.

\subsubsection{Biblioteker}
Filmanipulation har været en essentiel del af applikationslaget. Problemet er, at C++'s standardbiblioteker ikke indeholder funktionalitet til aflæsning af mappeindhold. Af denne årsag er tredjepartsbiblioteket Boost \cite{boost}, blevet benyttet.

\paragraph{Filhåndtering\\}
Filhåndteringen bliver delvist håndteret af tredjepartsbiblioteket Boost og delvist af  Fstream, der er en del af standardbiblioteket.

\paragraph{Fstream\\}
Fstream bliver brugt til at gemme og hente filer fra filsystemet.

\paragraph{Boost\\}
Boost er et anerkendt tredjepartsbibliotek med funktionaliteter som har tendens til at komme med i de efterfølgende version af C++ standardbiblioteket \cite{bibliotek}. Boost bruges af programmet til at gennemse mapper, så der kan dannes et filtræ, da Fstream ikke har den funktionalitet. 

\subsubsection{Komprimering}
For at forbedre overførselstiden af filer, er det valgt at gøre det muligt at benytte komprimering under overførsel af filer. 

Alle komprimeringsalgoritmer forsøger at mindske størrelsen på data’en, ved at fjerne redundante dele \cite{dsp}.

Til dette projekt er der blevet brugt et open-source bibliotek der hedder bzip2 \cite{bzip}. Bzip2 har flere fordele, der gør det til et godt valg:

{\setstretch{1}
\begin{itemize}
	\item Det er let at bruge.
	\item God komprimeringsratio ift. de fleste andre komprimeringsalgoritmer(10-15\% fra de bedste, og meget langsommere, tilgængelige algoritmer).
	\item Anerkendt og bredt benyttet bibliotek.
	\item Designet til at komprimere enkelte filer. Dette er fordelagtigt da der i projektet kun bliver transmitteret enkelte filer. 
\end{itemize}}

\subsubsection{Fejldetektering}
MD5 er en 128 bit hash, der bliver udregnet ud fra indholdet af en fil. En hashfunktion, kaldes også for en en-vejs funktion, der bruges til at danne en unik checksum. 

Når en fil er modtaget genereres en md5sum ud fra den. Denne sammenlignes med den medsendte md5sum. Hvis de ikke er ens er filen korrupt, og filen gemmes ikke.

Biblioteket Crypto++ \cite{crypto} er blevet benyttet til at beregne md5summen.

\subsubsection{Format}
Applikationslagets header er bygget op af tre felter, som det ses på figur 17.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.25]{Applikationslaget/applicationlayer_framestructure}
	\caption{Applikationslagets pakkeformat.}
\end{figure}

\subsubsection{Type}
Applikationslaget benytter en 5 bit header. Denne består af fire bit der bestemmer typen af pakken der sendes, samt én bit der fortæller om det er den sidste af den type.

\begin{table}[h]
	\centering
	\begin{tabular}{|l|c|}
		\hline \textbf{Type} & \textbf{Bit repræsentation} \\ 
		\hline Size & 0000 \\ 
		\hline Name & 0001 \\ 
		\hline Data & 0010 \\ 
		\hline RequestFile & 0011 \\ 
		\hline DeleteFile & 0100 \\ 
		\hline Message & 0101 \\ 
		\hline FiletreeRequest & 0110 \\ 
		\hline MakeFolder & 0111 \\ 
		\hline MD5Hash & 1000 \\ 
		\hline CompressedData & 1001 \\ 
		\hline RequestCompressedFile & 1010 \\ 
		\hline Filetree & 1011 \\ 
		\hline 
	\end{tabular}
	\caption{Typernes bitrepræsentation}
\end{table}

\paragraph{Final\\}
Dataen der leveres til datalinklaget må ikke være over en bestemt størrelse. Dette betyder, at dataen i visse tilfælde skal splittes op i flere pakker. \textit{Final} sættes til 0, så længe der leveres flere pakker af den samme type. Når den sidste pakke af én type leveres til datalinklaget, sættes Final til 1. På denne måde ved modtageren, at alt af samme datatype er blevet sendt.

\begin{description}
	\setstretch{1}
	\item[\textit{Size}]\hfill \\
	\textit{Size} benyttes til at fortælle modparten hvor mange frames den skal modtage.
	\item[\textit{Name}]\hfill \\
	\textit{Name} angiver filstien på en fil, der bliver sendt.
	\item[\textit{Data}]\hfill \\
	Data bruges når en fil skal sendes.
	\item[\textit{RequestFile}]\hfill \\
	RequestFile benyttes når der ønskes en fil tilsendt fra modparten. Denne indeholder filstien.
	\item[\textit{DeleteFile}]\hfill \\
	Bruges når afsenderenheden vil slette en fil hos modparten. Dataen i denne pakke er en filsti. Virker kun i CLI.
	\item[\textit{Message}]\hfill \\
	Hvis programmet kører i CLI, er det muligt at sende beskeder direkte til modpartens CLI.
	\item[\textit{FileTreeRequest}]\hfill \\
	Benyttes når brugeren ønsker at modtage et filtræ fra en bestemt destination hos modparten.
	\item[\textit{MakeFolder}]\hfill \\
	Bruges til at lave en mappe hos modparten. Der medsendes en filsti til den ønskede placering.
	\item[\textit{md5Hash}]\hfill \\
	Ved filoverførsel medsendes en MD5 hash checksum.
	\item[\textit{CompressedData}]\hfill \\
	Benyttes til at markere, at der sendes en komprimeret fil.
	\item[\textit{RequestCompressedFile}]\hfill \\
	Samme funktionalitet som \textit{RequestFile}, men kompression benyttes til overførslen.
	\item[\textit{FileTree}]\hfill \\
	Benyttes når der sendes et filtræ.
\end{description}

\subsubsection{Funktioner}
Applikationens primærer funktion er, at sende og modtage filer. Til dette formål er følgende funktioner blevet implementeret.

\paragraph{sendFile()}\mbox{}\\
Når en fil skal sendes bliver størrelsen på filen sendt som det første. Dette gør det muligt for modtageren at beregne hvor langt overførelsen er nået.

Det næste der bliver sendt, er navnet på filen og derefter md5summen. Til sidst bliver dataen sendt og verificeret af modtageren, før filen bliver gemt.

\begin{algorithm}[h]
	\caption{Sender komprimeret, eller ukomprimeret filer}
	\begin{algorithmic}[1]
		\Procedure{sendFile}{path,compress}
		\If{file exists}
			\State calculate number of frames to send
			\State send number of frames
			\State send path
			\State send md5sum
			\If{compress}
				\State send compressed file
			\Else
				\State send file
			\EndIf
			\State wait until transmitter buffer is empty
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\paragraph{requestFile()}\mbox{}\\
Når enheden ønsker at hente en fil fra modparten, foregår det ved, at der bliver sendt en \textit{RequestFile} pakke, med en filsti. Når denne pakken er modtaget, vil modparten påbegynde funktionen sendFile(), som beskrevet ovenover.

\begin{algorithm}[h]
	\caption{Sender en filanmoding}
	\begin{algorithmic}[1]
		\Procedure{requestFile}{path,compress}
		\If{compress}
		\State request compressed path
		\Else
		\State request path
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\paragraph{sendFileTree()}\mbox{}\\
Når der skal sendes et filtræ bliver der refereret til en mappe hvori man vil have et overblik over filerne. Navnene på alt indhold i denne mappe bliver sendt til modtageren.

\begin{algorithm}[h]
	\caption{Sender filtræet til modparten}
	\begin{algorithmic}[1]
		\Procedure{sendFileTree}{path}
		\If{path is a directory}
		\State initialize string to obtain file names
		\For{items in directory}
		\State add item path to string
		\EndFor
		\State send compressed string
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\newpage
\paragraph{requestFileTree()}\mbox{}\\
Når enheden ønsker at modtage et filtræ, sker det ved at der bliver sendt en \textit{RequestFileTree} pakke, hvor en filsti bliver sendt. Når denne pakke er modtaget, vil modparten påbegynde funktionen sendFileTree(), som beskrevet ovenover.

\begin{algorithm}[h]
	\caption{Anmoder om et filtræ fra modparten}
	\begin{algorithmic}[1]
		\Procedure{requestFileTree}{path}
		\State clear old file tree
		\State send request file tree at path
		\State wait for file tree
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\paragraph{makeFolder()}\mbox{}\\
Når det ønskes at lave en ny mappe hos modparten, skal der sendes en \textit{MakeFolder} pakke.

\begin{algorithm}[h]
	\caption{Sender: Anmoder om at lave en ny mappe hos modparten.}
	\begin{algorithmic}[1]
		\Procedure{requestMakeFolder}{path}
		\State send requestMakeFolder with path
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{Modtager: Laver en ny mappe.}
	\begin{algorithmic}[1]
		\Procedure{makeFolder}{path}
		\State create directory at path
		\If{directory not created}
		\State send error message
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\paragraph{deletePath()}\mbox{}\\
Hvis afsenderenheden ønsker at slette en fil, eller en mappe hos modparten, kan der sendes en \textit{DeleteFile} pakke med en filsti. Hos modparten bliver filstien modtaget og det kontrolleres om filstien eksistere. Hvis filstien ikke eksisterer bliver der sendt en fejlbesked tilbage til afsenderenheden. 

Eksistere filen, kontrolleres der om filstien angiver en regulær fil, hvis dette er tilfældet slettes denne. Angiver filstien en mappe, bliver mappen med dens indhold slettet. 
I begge tilfælde, bliver der sendt en besked tilbage til afsenderenheden om, at enten filen eller mappen er blevet slettet.

\begin{algorithm}[h]
	\caption{Sender: Anmoder om at slette en filsti hos modparten.}
	\begin{algorithmic}[1]
		\Procedure{requestDeleteFile}{path}
		\State requestDeleteFile with path
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
	\caption{Modtager: Sletter en filsti.}
	\begin{algorithmic}[1]
		\Procedure{deleteFile}{path}
		\If{path exists}
		\If{path is regular file}
		\State delete file at path
		\ElsIf{path is directory}
		\State delete directory at path
		\EndIf
		\Else
		\State send error message
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\subsubsection{Modtagertråden}
Applikationslaget er delt op i to parallelle tråde. Den ene står for modtagelse af data fra datalinklaget og foregår i baggrunden. Den anden modtager kommandoer fra brugeren, splitter pakker op og leverer dem til datalinklaget. Se figur 18.

Modtagertrådens opgave er, at modtage forespørgsler, filtræer, samt filer fra modparten.
Modtagertråden står kontinuerligt og venter på, at der kommer en pakke fra datalinklaget.

Når der modtages en pakke sker følgende, alt afhængigt af typen:

\begin{description}
	\setstretch{1}
	\item [\textit{Size}]\hfill \\
	Antallet af frames der skal modtages, leveres videre til brugerfladen.
	
	\item [\textit{Name}]\hfill \\
	Gemmer navnet på den modtagne fil.
	
	\item [\textit{Data}]\hfill \\
	Ved \textit{Data} skal der foretages et tjek. Den modtagne datas md5sum sammenlignes med den modtagne md5sum. Hvis de er ens bliver filen gemt.
	
	\item [\textit{CompressedData}]\hfill \\
	Her foretages det samme som ved data, men dataen bliver først udpakket.
	
	\item [\textit{FileRequest}]\hfill \\
	Ved \textit{FileRequest} sendes den forespurgte fil tilbage med funktionen sendFile().
	
	\item [\textit{DeleteFile}]\hfill \\
	Ved DeleteFile, benyttes funktionen deleteFile(), med den angivne sti.
	
	\item [\textit{Message}]\hfill \\
	Skriver beskeden ud i CLI.
	
	\item [\textit{FileTreeRequest}]\hfill \\
	Ved \textit{FileTreeRequest}, benyttes funktionen sendFileTree().
	
	\item [\textit{MakeFolder}]\hfill \\
	Ved \textit{MakeFolder}, benyttes funktionen makeFolder().
	
	\item [\textit{md5sum}]\hfill \\
	md5summen bliver gemt til senere brug.
	
	\item [\textit{FileTree}]\hfill \\
	Hvis der bruges CLI, bliver filtræet printet ud på skærmen, ellers bliver det leveret til GUI.
\end{description}
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.37]{Applikationslaget/applicationlayer_receiver}
	\caption{Flowchart over receiver tråden}
\end{figure}

\subsubsection{Console Line Interface}
Der er blevet udviklet et CLI til at forespørge om og sende filer, filtræer og beskeder. For at udvide brugervenligheden er der blevet implementeret autocompletion ved hjælp af GNU libreadline \cite{readline}.

CLI er det primære interface der er blevet brugt til projektet. Af sammen årsag er der en større funktionalitet end i GUI’en. Kommandoerne til CLI kan ses i tabel 5.

\begin{table}[h]
	\begin{tabular}{|l|l|l|}
		\hline \textbf{Kommando i CLI} & \textbf{Parameter} & \textbf{Funktion(parameter liste)} \\ 
		\hline send & <filename> & sendFile(fileName,targetFilename,0) \\
		& <target filename> (optional) & \\
		\hline sendcompressed & <filename> & sendFile(fileName,targetFilename,1) \\
		& <target filename> (optional) & \\
		\hline request & <filename> & requestFile(fileName,targetFilename,0) \\
		& <target filename> (optional) & \\
		\hline requestcompressed & <filename> & requestFile(fileName,targetFilename,1) \\
		& <target filename> (optional) & \\
		\hline filetree &  & sendFileTree() \\ 
		\hline delete & <path> & requestDeleteFile(path) \\ 
		\hline sendmessage & <message> & sendMessage(message) \\ 
		\hline makedir & <path> & makeFolder(path) \\ 
		\hline 
	\end{tabular}
	\caption{Funktionalitet for CLI} 
\end{table}

\subsubsection{Graphical User Interface}
Der er udviklet en GUI, som gør programmet mere overskueligt for brugeren. Brugerfladen er et vindue, hvor brugeren har mulighed for enten at sende en fil, eller anmode om en fil fra en anden enhed.

Programmet har to faner: Request File og Send File, bruges henholdsvis til at anmode om og sende filer.

\paragraph{Qt}\mbox{}\\
Qt \cite{qt} er et multiplatformsbibliotek af brugerflade elementer, som bliver udviklet af Qt Company (tidligere Digia) og Qt Project som et Open-source projekt. Qt brugerfladen er eventbaserest, hvilket vil sige, at programmet sidder i en ventetilstand, indtil  en funktion kaldes af et event.

\paragraph{Procesbar}\mbox{}\\
I bunden af vinduet er en procesbar, som viser programmets aktuelle status. Ved opstart står procesbaren i standbytilstand (se figur 19), hvilket indikerer, at programmet venter på data. Så snart en overførsel startes, skifter procesbaren fra standby tilstand, til at vise status for den aktuelle overførsel. Dette gøres både hos afsender og modtager.

Når Request File fanen bruges, viser procesbaren ikke status i afsenderens GUI, da dette ville kræve en omstrukturering af koden i applikationslaget. Ligeledes viser procesbaren ikke status ved overførsel af filtræ hos hverken afsender og modtager.

\paragraph{Send File}\mbox{}\\
Send File fanen indeholder fire elementer; en tekstboks der viser filstien til den valgte fil, en Choose file knap, en Send knap og procesbaren. Se figur 19.

Når en fil er valgt og Send knappen trykkes, går programmet i gang med at sende filen. Procesbaren skifter til at vise hvor langt overførslen er nået og Send knappen bliver deaktiveret, hvilket forhindre brugeren i at sende flere filer samtidig.

\begin{figure}[h]
	\begin{center}
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[scale=0.5]{GUI/sendfileidle}
		\end{minipage}
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[scale=0.5]{GUI/sendfilesending}
		\end{minipage}
		\caption{Send File fanen}
	\end{center}
\end{figure}

\paragraph{Request File}\mbox{}\\
Request File fanen bruges til at gennemse indholdet af den anden enhed og få tilsendt en fil. Fanen indeholder fire elementer; Request tree knappen, der anmoder om at få et filtræ tilsendt; Download knappen, der henter den valgte fil; et vindue, der viser filer og mapper i den nuværende mappe og procesbaren, der viser programmets aktuelle status. Se figur 20.

Download knappen er deaktiveret hvis der ikke er valgt en fil. Når en fil er valgt, og Download knappen trykkes, går overførslen i gang.

\begin{figure}[h]
	\begin{center}
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[scale=0.5]{GUI/requestfilefiletree}
		\end{minipage}
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[scale=0.5]{GUI/requestfilereceiving}
		\end{minipage}
		\caption{Request File fanen}
	\end{center}
\end{figure}

Når en overførsel er færdig, går procesbaren tilbage til standby tilstand. Brugeren bliver ikke gjort opmærksom om md5summen ikke passer.

\subsection{Delkonklusion}
Det endelige produkt er en filoverførselsapplikation. Der blev designet en protokol, som er forbindelsesorienteret, halv-dupleks og baseret på Stop-and-Wait. Dertil er udviklet en applikation der kan køres med eller uden GUI.

Applikationen er bygget op af lag, som kan udskiftes, siden der er lav kobling.

\section{Softwareudvikling}
En del af projektbeskrivelsen var indkluderingen af faglighederne fra softwareudvikling.

\subsection{Revisionsstyring}
I projektet er revisionsstyringssystemet Git benyttet til at holde styr på ændringer i kildekoden. Dette gør det muligt at have en komplet liste over hvilke ændringer der er foretaget af hvem, samt hvornår. Samtidig er det også lettere at arbejde på flere forskellige dele af programmet samtidig.

\subsubsection{Hvad er Git?}
Git er et distribueret revisionsstyringssystem, som er udviklet af Linux-grundlæggeren Linus Torvalds. Systemet blev oprindeligt udviklet for at håndtere koden i Linux-kernen men er siden blevet brugt af mange andre projekter, f.eks. GCC, Perl, VLC \cite{gitprojekt} og Facebook \cite{facebook}, og er efterhånden blevet et af de mest brugte revisionsstyringssystemer \cite{eclipse}.

\subsubsection{Fordele ved Git}
\begin{itemize}
	\item Designet til ulineær udvikling:\\
	Git er designet til hurtigt at kunne lave nye forgreninger af koden, og flette dem sammen igen. Dette gør det let at udvikle softwaren ulineært, altså udvikle på forskellige dele af koden samtidig og til sidst flette ændringerne sammen. Dette er meget fordelagtigt når der samarbejdes omkring udviklingen i flere små grupper.
	
	\item Revisionslog:\\
	Det er muligt at se en log over hvilke ændringer der er sket i kildekoden og hvornår. Dette er en stor fordel når der er opstået en fejl, og man derfor kan gå tilbage til en version af koden hvor fejlen ikke eksisterer.
\end{itemize}

\subsubsection{Vores brug af Git}
I projektet er GitHub \cite{github} benyttet til at hoste et git arkiv\footnote{{https://github.com/Projektgruppe3-RobTek/DTMFMagix}}, som man kan hente fra og uploade til. Dette gør det muligt at kopiere arkivet fra Github, lave ændringer og uploade ændringerne.

\subsection{Emulering af det fysiske lag}
For at gøre det lettere og hurtigere at fejlsøge de øvre lag, er der blevet udviklet en simpel emulator af det fysiske lag. Dette gjorde det muligt at udvikle det fysiske lag og datalinklaget parallelt.

Emulatoren tilbyder de samme offentlige funktioner som det rigtige fysiske lag, der kan derfor skiftes imellem dem uden at lave ændringer på de øvre lag.

Emulatoren fungerer ved at der skrives to filer til harddisken. Den ene fil indeholder oplysninger om hvorvidt der er kommet ny data (et tal tælles op hver gang der kommer ny data), mens den anden indeholder den data der sendes.

I emulatoren er der implementeret en mulighed for at vende en brøkdel af de overførte bit. Dette gør det muligt at teste og fejlfinde fejlkontrollen på datalinklaget, uden at benytte det langsomme lydmedie.

For at benytte emulatoren skal to instanser af programmet startes fra samme mappe. Disse to programinstanser vil herefter kunne kommunikere med hinanden.

\subsubsection{Fordele ved emulatoren}
{\setstretch{1}
\begin{itemize}
	\item De øvre lag kan testes uafhængigt af eventuelle fejl på det fysiske lag.
	\item De øvre lag kan testes med kun én computer.
	\item Det er hurtigere at udføre tests af de øvre lag, da overførslen foregår langt hurtigere.
	\item De øvre lag kan udvikles parallelt med det fysiske lag.
	\item Fejl kan emuleres med en selvvalgt fejlfrekvens.
\end{itemize}}

\subsubsection{Ulemper ved emulatoren}
{\setstretch{1}
\begin{itemize}
	\item Timing indstillingerne på datalinklaget kan ikke testes med emulatoren.
	\item Bitstuffing på datalinklaget kan ikke testes da emulatoren ikke benytter start- og slutflag
	\item Emulatoren skriver filer til harddisken meget hurtigt og mange gange. Dette kan forårsage slitage på visse harddisktyper. Dette kan omgås ved f.eks. at skrive filerne til RAM i stedet.
\end{itemize}}

\subsection{Designklassediagram}
Et designklassediagram er et softwareartefakt i Unified Process.

Programmet er designet således, at klasserne er afhængige af hinanden. Applikationslaget kan ikke fungere, hvis et datalinklag ikke er forbundet. Ligeledes kan datalinklaget ikke fungere, hvis et fysisk lag ikke er forbundet. Det samme gælder også for det fysiske lag, Playeren, og Recorderen. 

Denne forbindelse mellem klasserne kaldes for en aggregering. Da denne afhængighed kun fungerer den ene vej, betyder det også at man kan skifte de forskellige klasser ud, med en klasse der har samme snitflader.

Funktionerne og attributterne på figur 21, viser kun de funktioner der skal bruges for at kunne sende og modtage data mellem to enheder der er forbundet.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.16]{design_klasse_diagram}
	\caption{Designklassediagram over produktet i UML-notation.}
\end{figure}

\subsection{Singletonobjekter}
Mange af klasserne der er brugt i programmet må kun eksistere i en enkelt instans, da objekterne ellers kan risikere at snakke med sig selv. Hvis der prøves at initialiseres et nyt objekt, bliver det eksisterende objekt returneret i stedet, da alle lag oprettes som singletonobjekter.

\section{Diskussion}
Effektiviteten af produktet bliver i dette afsnit diskuteret sammen med en række relevante udfordringer, tests og valg, der har været i projektforløbet.

\subsection{Synkronisering ved støj}
Produktet er afhængig af at synkroniseringen foregår pålideligt. Det skal derfor kunne lade sig gøre, selv i støjfyldte miljøer. Her forekommer der dog et problem, der skyldes den måde som synkroniseringen er implementeret på.

En tone bliver registreret som ny, når den er forskellig fra den forrige. Hvis eksempelvis sekvensen: AAAA66668888 forekommer, registreres det som A68. Dette giver dog et problem, hvis der er betydelig støj. Det kunne tænkes, at der på grund af støj i stedet forekommer: AAAA66568888. Dette registreres som A6568. Et enkelt støjsignal kan altså ødelægge sekvensen, og det er ikke muligt at synkronisere. Det kræver dog at støjsignalet indeholder en af DTMF frekvenserne. For at undgå problemet, afspilles synkroniseringssekvensen fem gange, da støjsignalet så skal forekomme i alle fem optagelser, for at forstyrre synkroniseringen.

\subsection{Forbedringer til det fysiske lag}
Et tiltag på det fysiske lag kunne være at ændre synkroniseringssekvensen således at enhederne synkroniseres når programmet startes. Denne synkronisering benyttes resten af tiden programmet kører. Efterfølgende sendes kun frames uden synkroniseringssekvensen, og overførelsestiden ville blive nedsat drastisk. Denne implementering ville sænke antallet af bit, der skal sendes per pakke med ~16 \%.

Dette kan gøres da computerens clock ikke driver betydeligt over kortere tidsperioder. Det ville derfor først være nødvendigt at synkronisere igen efter lang tid.

\subsection{Datalinklagets fejlresistens}
Datalinklaget er opbygget som en pålidelig protokol, og skal derfor være resistent overfor fejl. Fejlresistensen på datalinklaget fungerer korrekt. Dette er bl.a. dokumenteret under stresstesten i [B5],  hvor over 60 \% af de sendte pakker var korrupte lykkedes det stadig at få overført filer uden fejl. Emulatoren af det fysiske lag er blevet brugt til at kontrollere datalinklagets fejlresistens.

\subsection{Forbedringer til datalinklaget}
Protokollen kan forbedres, da der bruges meget tid på at vente på ACK. Ved f.eks. at benytte en protokol hvor  der sendes en gruppe af pakker ad gangen, hvorefter modtager sender en enkelt ACK som indeholder pakke nummeret på alle pakker der er modtaget korrekt. Således skal et mindre antal ACK sendes.

Ydermere er timerens tid statisk, hvilket vil sige, at den venter samme tid selvom pakkerne der sendes er forskellige størrelse. Timeren er sat til at vente på den maksimale størrelse af en pakke, hvilket giver en del spildtid. Dette kunne optimeres ved at gøre timeren dynamisk, så der kun ventes den nødvendige tid. Dette var forsøgt i slutningen af projektet, men grundet problemer blev det valgt at bruge statisk tid.

\subsection{Fejlkontrol}
CRC tjekket er på den enkelte frame, så hvis der bliver opfanget en fejl i CRC tjekket, gensendes framen. Er der derimod en fejl i md5summen, skal hele filen sendes igen. For at undgå dette bruges der et sikkert CRC tjek.

\subsection{Problemer under test}
Som en del af udviklingen og optimeringen af produktet blev der udført en række test. Det viste sig dog at være vanskeligt at lave forsøgsopstillingerne konsistente, specielt [B4,B5]. Problemstillingen i testene gik fra at finde de mest optimale indstillinger, til at finde flaskehalse blandt en lang række af indstillinger og funktioner i koden, da mange af parametrene igennem koden er afhængige af hinanden.

Når der blev opstillet en række forsøg, hvor en enkelt indstilling blev ændret gradvist, viste forsøgene, at “kurven” knækkede meget pludseligt, hvorefter det slet ikke virkede. Der blev altså ikke set en gradvis forringelse, grundet ikke optimale indstillinger. I stedet blev der stødt på en flaskehals, som kunne ligge helt andre steder i programmet. Et eksempel på dette er da optagerens samplerate blev testet. Her blev der set en forbedring i hvor meget tonelængden kunne nedsættes. Dette virkede kun i de første tests, hvor tonelængden blev sat lidt ned. Når den blev sat yderligere ned, havde optagerens samplerate ingen indflydelse, og problemet skulle i stedet findes i indstillingerne omkring ventetider, før pakker blev gensendt.

Dette betød derfor, at der under testene blev lavet mange mindre ændringer rundt omkring i programmet, og rettet forskellige fejl, som ikke kunne relateres til den givne forsøgsopstilling. De fleste af resultaterne fra testene er derfor meget inkonsistente, og en stor del af testene blev aldrig færdiggjorte, eller gav så dårlige data, at de måtte kasseres. De angivne resultater er derfor udvalgt fra test, der resulterede i informativ data.

\subsection{Tonelængde}
Generelt opstår der flere fejl og der skal gensendes flere frames, jo kortere tonelængde der benyttes. Samtidig vil overførselstiden per frame formindskes, jo kortere tonelængde, der benyttes. Forskellige test har vist, at succesraten for frames i forhold til tonelængden er meget afhængig af det miljø som overførslen finder sted i [B5]. 

Den totale overførselshastighed er både afhængig af hvor mange frames, der skal gensendes, samt overførselshastigheden på de enkelte frames.

Der bør derfor så vidt muligt findes et kompromis med tonelængden, så der opnås en høj overførselshastighed, samtidig med, at der ikke mistes for mange pakker undervejs. Testene i det optimale støjfri miljø, gav mulighed for tonelængder ned til 25 ms, uden store tab af frames, mens test i støjfyldt miljø, gav helt andre resultater ved 25-28 ms. Der er derfor valgt et kompromis med en tonelængde på omkring 30 ms, hvilket har vist sig at være acceptabelt, selv i et støjfyldt miljø, hvor der kan forventes tab af frames.

\subsection{Databit per sekund}
Der er blevet udarbejdet et regneark hvor effektiviteten af produktet er blevet udregnet. Dette kan ses i [B6,B7]. Effektiviteten er blevet beregnet i den mængde af data der bliver overført på applikationslagsniveauet. Med de valgte indstillinger, bliver der sendt op til 83 databit per sekund.

\newpage
\section{Konklusion}
Der er blevet udviklet en applikation, der gør det muligt for to enheder at sende filer indbyrdes ved hjælp af DTMF toner. Denne applikation er opdelt i tre lag: et fysisk lag, et datalinklag og et applikationslag.

På det fysiske lag er der blevet benyttet et start- og slutflag til at afgrænse en frame. Samtidig er der før startflaget indsat en sykroniseringssekvens, for at synkronisere enhederne.
Goertzelalgoritmen benyttes til at opfange DTMF toner, og fungerer samtidig som støjfiltrering.

På datalinklaget er der blevet udviklet en forbindelsesorienteret Stop-and-Wait protokol, som er halv-dupleks. Dette er gjort for at undgå kollisioner på transmissionsmediet. Protokollen er lavet pålidelig med implementeringen af CRC, ID og ACK. Samtidig er der indsat et ekstra integritetstjek på applikationslaget i form af en md5sum.

Der er blevet udviklet en grafisk brugerflade til applikationen med begrænset funktionalitet. Der er samtidig blevet inkluderet en komprimeringsalgoritme på applikationslaget, der mindsker overførselstiden for de fleste filer.

Produktet opfylder kravene stillet i projektet og fungere efter hensigten. Applikationen er teoretisk i stand til at sende op til 83 data bit per sekund, med en tonelænge på 30 ms og en pause mellem tonerne på 3 ms. Dette giver en acceptabel succesrate i forhold til gensendelse af korrupte frames.

\newpage
\section{Ordliste}
{\setstretch{1.1}
\begin{description*}[]
	\item[ACK] \hfill \\ Acknowledgement
	\item[C++11] \hfill \\ Er en nyere version af C++. Valget af denne version er på grund af første parts indkludering af multithreading.
	\item[Callback funktion] \hfill \\ En funktion der gives som parameter til en anden funktion, og som aktiveres ud fra fastsatte events.
	\item[CLI] \hfill \\ Console Line Interface.
	\item[DFT] \hfill \\ Discrete Fourier Transformation.
	\item[Dupleks] \hfill \\ Definerer hvorvidt point-til-point systemet fungere en- eller to-vejs.
	\item[DTMF] \hfill \\ Dual Tone Multi Frequency toner er en matrix på 16 toner, af to sæt á fire frekvenser.
	\item[FDMA] \hfill \\ Frequency Division Multiple Access \cite[s. 344-345]{datakom}
	\item[FFT] \hfill \\ Fast Fourier Transformation.
	\item[FIR] \hfill \\ Finite Impulse Response, er et digitalt filter, der har et begrænset impulssvar.
	\item[FTP] \hfill \\ File Transfer Protocol, er en protokol til filoverførsel.
	\item[GUI] \hfill \\ Graphic User Interface.
	\item[IIR] \hfill \\ Infinite Impulse Response, er et digitalt filter, der har et ubegrænset impulssvar.
	\item[Heap] \hfill \\ Et stort hukomelseområde, der håndteres af styresystemet. Programmet kan anmode systemet om hukommelse fra området. Heapen bruges normalt til store datastrukturer.
	\item[Klasse] \hfill \\ En programstruktur, der benyttes til at isolerer forskellige typer funktionalitet fra det omkringliggende program, og en “opskrift” til at skabe selvstændige objekt instanser. 
	\item[Nibble] \hfill \\ 4 bit.
	\item[Nyquist Frekvensen] \hfill \\ Den halve sampling frekvens.
	\item[Pålidelig] \hfill \\ At en protokol er pålidelig betyder, at det er sikret, at den overførte information overføres uden fejl og kommer frem til modtageren.
	\item[Stack] \hfill \\ Et hukommelsesområde, som primært indeholder oplysninger om hvilken rækkefølge der skal returneres til underliggende funktioner. Stacken kan også indeholde små og midlertidige variabler og datastrukturer
	\item[Store O-notation] \hfill \\ Angiver beregningseffektiviteten.
	\item[Threadsafe] \hfill \\ En datastruktur er threadsafe hvis delt data tilgås på en sådan måde at flere tråde kan tilgå den samtdig uden at dataintegriteten beskadiges.
	\item[Tråd] \hfill \\ Tråde er en funktionalitet der gør det muligt at håndtere flere processer parallelt.
\end{description*}}

\begin{thebibliography}{9}

{\setstretch{1.1}
\bibitem{datakom}
	Forouzan, Behrouz A., and Sophia Chung. Fegan. Data Communications and Networking. 5th ed. New York: McGraw-Hill Higher Education, 2007. Print.
	
\bibitem{goertzel}
	Evans, Brian L. "Goertzel Algorithm." Goertzel Algorithm. Berkeley, 30 Aug. 1994. Web. 17 Dec. 2014.
	
\bibitem{cryptopp}
	Dai, Wei. "Crypto++ 5.6.0 Benchmarks." Speed Comparison of Popular Crypto Algorithms. Cryptopp, 31 Dec. 2009. Web. 17 Dec. 2014.
	
\bibitem{sdl}
	Lantinga, Sam. "Wiki." SDL OpenAudioDevice. SDL Community, 16 Mar. 2014. Web. 17 Dec. 2014.
	
\bibitem{portaudio}
	Burk, Phil. "PortAudio - an Open-Source Cross-Platform Audio API." PortAudio - an Open-Source Cross-Platform Audio API. PortAudio, 27 Jan 2012. Web. 17 Dec. 2014.
	
\bibitem{boost}
	Abrahams, David. "Boost C++ Libraries." Boost C++ Libraries. Boost, 1 Nov. 2003. Web. 17 Dec. 2014.
	
\bibitem{bibliotek}
	Austern, Matthew. "Library Technical Report." Library Technical Report. Open STD, 09 Apr. 2003. Web. 17 Dec. 2014.

\bibitem{dsp}
	Wade, J. G. Signal Coding and Processing. Cambridge: Cambridge UP, 1994. 34. Print.
	
\bibitem{bzip}
	Julian. "Bzip2 and Libbzip2." Bzip2 : Home. Bzip, 20 Sept. 2010. Web. 17 Dec. 2014.
	
\bibitem{readline}
	Ramey, Chet. "The GNU Readline Library." The GNU Readline Library. GNU, 9 Dec. 2014. Web. 17 Dec. 2014.
	
\bibitem{qt}
	Nord, Haavard, and Eirik Chamber-Eng. "Qt Project." Qt Project. Gitorious, 10 Dec. 2014. Web. 17 Dec. 2014.

\bibitem{eclipse}
	Skerrett, Ian. "Eclipse Community Survey 2014 Results." Ian Skerrett. Eclipse, 23 June 2014. Web. 17 Dec. 2014.}

\bibitem{github}
	Preston-Werner, Tom, Chris Wanstrath, and PJ Hyett. "Build Software Better, Together."GitHub. Git, 10 Apr. 2008. Web. 17 Dec. 2014.
	
\bibitem{gitprojekt}
	The Linux Foundation. "GitProjects." Git Wiki. Git Wiki, 5 Apr. 2014. Web. 17 Dec. 2014.
	
\bibitem{facebook}
	Facebook. "Facebook." GitHub. Facebook, n.d. Web. 17 Dec. 2014.
	
\bibitem{crypto}
	Dai, Wei. "Crypto++® Library 5.6.2." Crypto++ 5.6.2. Crypto++, 20 Feb. 2013. Web. 17 Dec. 2014.
\end{thebibliography}

\section{Bilag}

Herunder ses en oversigt over de vedlagte bilag.
Alle findes på den vedlagte DVD.
\subsection*{Bilagsfortegnelse}
{\setstretch{1.1}
\begin{description*}
	\item {[}B1{]} Index til det elektroniske medie
	\item {[}B2{]} Afgrænsende\_Tests.pdf
	\item {[}B3{]} Indstilling\_af\_Player.pdf
	\item {[}B4{]} Indstilling\_af\_Record.pdf
	\item {[}B5{]} Indstilling\_af\_Tonelængde.pdf
	\item {[}B6{]} Teoretisk\_Effektivitet.pdf
	\item {[}B7{]} Teoretisk\_Effektivitet\_Regneark.pdf
\end{description*}}

\newpage
\subsection*{Index til det elektroniske medie}
{\setstretch{1.1}
\begin{multicols}{2}
\begin{itemize*}
	\footnotesize
	\item Figurer
	\begin{itemize}
		\item Complete\_Framestructure.png
		\item Design\_Klasse\_Diagram.png
		\item Applikationslag
		\begin{itemize}
			\item ApplicationLayer\_Framestructure.png
			\item ApplicationLayer\_Receiver.png
		\end{itemize}
		\item Datalinklag
		\begin{itemize}
			\item DatalinkLayer\_Buffer.png
			\item DatalinkLayer\_Framestructure.png
			\item DatalinkLayer\_Receiver.png
			\item DatalinkLayer\_Transmitter.png
		\end{itemize}
		\item Den grafiske brugerflade
		\begin{itemize}
			\item GUI\_Filebrowser.png
			\item RequestFile\_FileTree.png
			\item RequestFile\_Idle.png
			\item RequestFile\_Receiving.png
			\item SendFile\_Idle.png
			\item SendFile\_Sending.png
		\end{itemize}
		\item Det fysiske lag
		\begin{itemize}
			\item PhysicalLayer\_Callback\_Function.png
			\item PhysicalLayer\_Get\_Threads.png
			\item PhysicalLayer\_Framestructure.png
			\item PhysicalLayer\_SendThread.png
			\item Recorder\_Get\_Samples.png
			\item Ampliture1.png
			\item Ampliture2.png
			\item Ampliture3.png
			\item Sampling1.png
			\item Sampling2.png
			\item Sampling3.png
			\item DTMF\_Toner.png
		\end{itemize}
	\end{itemize}
	\item Kode
	\begin{itemize}
		\item AppLayer.cpp
		\item AppLayer.h
		\item DTMFTones.cpp
		\item DTMFTones.h
		\item DataLinkLayer.cpp
		\item DataLinkLayer.h
		\item Goertzel.cpp
		\item Goertzel.h
		\item main.cpp
		\item PhysicalLayer.cpp
		\item PhysicalLayer.h
		\item PhysicalLayerEmu.cpp
		\item PhysicalLayerEmu.h
		\item Player.cpp
		\item Player.h
		\item Recorder.cpp
		\item Recorder.h
		\item RingBuffer.h
		\item autoCompletion.cpp
		\item autoCompletion.h
		\item dtmfmagix.cpp
		\item dtmfmagix.h
		\item mythread.h
		\item mythread.cpp
		\item dtmfmagix.ui
		\item Makefile
		\item README.md
	\end{itemize}
	\item Test
	\begin{itemize}
		\item Afgrænsende\_Tests.pdf
		\item Indstilling\_af\_Player.pdf
		\item Indstilling\_af\_Recorder.pdf
		\item Indstilling\_af\_Tonelængde.pdf
		\item Teoretisk\_Effektivitet.pdf
		\item Teoretisk\_Effektivitet\_Regneark.xslx
		\item Test\_Resultater.xslx
		\item Player\_Test\_Billeder
		\begin{itemize}
			\item scope\_n.png (53)
			\item Player\_Test\_Data.pdf
		\end{itemize}
	\end{itemize}
	\item Rapport.pdf
	\item Projektoplæg.pdf
\end{itemize*}
\end{multicols}
}

\end{document}