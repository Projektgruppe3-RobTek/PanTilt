\documentclass[a4paper,11pt,danish,oneside]{article}

\usepackage[utf8]{inputenc}

\usepackage[danish]{babel}

\usepackage{graphicx}

\usepackage[top=3cm, bottom=3cm, left=2.5cm, right=3.5cm]{geometry}

\usepackage{tocvsec2}

\usepackage{float}

\usepackage{pdfpages}

\usepackage{tabularx}

\usepackage{parskip}

\usepackage{mathtools}

\usepackage{changepage}

\usepackage{mdwlist}

\graphicspath{ {./Billeder/} }

\linespread{1.1}

\begin{document}

\begin{titlepage}
\begin{center}
\textsc{\LARGE Syddansk Universitet}\\[1.5cm]

\textsc{\Large 3. Semester Projekt}\\[0.5cm]

\textsc{\large RobTek E14}\\[0.5cm]
% Title
\rule{\linewidth}{0.5mm}\\[0.4cm]
{ \huge \bfseries DTMF kommunikation\\[0.4cm]}
\rule{\linewidth}{0.5mm}\\[1.5cm]

% Author and supervisor
\textbf{Gruppe 3}\\
Frederik Haarslev - 100694\\
frhaa13@student.sdu.dk\\[0.5cm]
Martin Steenberg Staal - 280694\\
masta13@student.sdu.dk\\[0.5cm]
Niels Hvid - xxxxxx\\
niehv13@student.sdu.dk\\[0.5cm]
Nikolaj Leth - xxxxxx\\
nilet13@student.sdu.dk\\[0.5cm]
Rasmus Staggsted - xxxx94\\
rasta13@sudent.sdu.dk\\[0.5cm]
Stefan Ravn van Overeem - 280394\\
stove13@student.sdu.dk\\[0.5cm]
Theis Strøm-Hansen - 270792\\
thstr13@student.sdu.dk\\[1cm]

\textbf{Vejleder:} Ib Reifer

\vfill

% Bottom of the page
{\large \today}
\end{center}
\end{titlepage}

\section*{Forord}
Vi vil gerne takke vores vejleder, Ib Refer, for at have stået til rådighed og for vejledning gennem hele projektforløbet. 

Den primære arbejdsfordeling har været som følger:
\begin{itemize}
	\item Frederik, Niels og Nikolaj har stået for det fysiske lag.
	\item Martin og Stefan har stået for datalinklaget.
	\item Rasmus og Theis har stået for applikationslaget.
	\item Frederik, Niels og Nikolaj har stået for den grafiske brugerflade.
	\item Nikolaj og Stefan har været de primære aktører i udførelsen af de praktiske tests.
	\item Hele gruppen har været involveret i skrivning af rapporten.
\end{itemize}

\tableofcontents

\section{Indledning}

Datakommunikation er disciplinen, at udveksle data mellem to eller flere enheder. Datakommunikation er en væsentlig del af vores hverdag, og benyttes i store dele af vores daglige aktiviteter, såsom at surfe på internettet, sende sms’er, ringe til familien eller uploade og downloade data. Normalt benyttes disse tjenester, uden at der tænkes nærmere over, hvad der ligger bag. Realiteten er at mange forskellige protokoller og teknologier er i spil for at disse tjenester, kan fungere.

Datakommunikation kan i mange tilfælde ikke fungere alene, og der er ofte brug for signalbehandling til at behandle de signaler, der bærer dataen.

I dette projekt arbejdes der med kommunikation vha. lyd.
Målet med projektet er at udvikle en applikation som, ved hjælp af forskellige kommunikationsprotokoller, kan få to eller flere enheder til at kommunikere med DTMF(*) toner. Applikationen skal skrives i C++, og skal opbygges som en lagdelt arkitektur. Der skal hertil inkorporeres forskellige elementer fra digital signalbehandling for bl.a. at fjerne støj. Der er til projektet blevet udleveret to \textit{Logitech\textsuperscript{TM} Stereo Speakers Z120} og to \textit{Logitech\textsuperscript{TM} Analog Desktop Microphones}.

Projektet endte ud med en point-to-point fildelings applikation, som er i stand til at:

\begin{itemize}
	\item Oprette forbindelse mellem to enheder.
	\item Sende eller anmode om filer.
	\item Udfører fejlkontrol på sendte filer.
\end{itemize}
Ydermere er der designet en grafisk brugerflade til applikationen.

Denne rapport indeholder en detaljeret gennemgang, af den udviklede applikation, og de valg der er foretaget i løbet af projektperioden.
\section{Projektafgrænsning}
Der udvikles en fildelingsapplikation, som skal være i stand til at sende og modtage filer mellem to enheder. Fokus vil ligge på at gøre protokollen robust og pålidelig, frem for hurtig, for at sikre, at den overførte data er fejlfri.

Der blev foretaget afgrænsende tests [B1]. Ved brug af flere højtalere kan det medføre negativ interferens, hvis højtalerne står forkert i forhold til hinanden. Af denne årsag er der valgt kun at bruge én højtaler, som placeres tæt på mikrofonen.

Produktet opbygges som en lagdelt software arkitektur. Med udgangspunkt i OSI modellen udvælges der tre af de følgende syv lag. Hertil tilstræbes det at have lav kobling mellem lagene.

\begin{itemize}
	\item Applikationslaget - Medtages da applikationen skal sende/modtage data. 
	\item Præsentationslagets - Fravælges idet protokollen skrives specifikt til applikationen.
	\item Sessionslaget - Fravælges da der ikke anvendes TCP.
	\item Transportlaget - Fravælges da kun en applikation bruger protokollen, så portnumre er irelevante.
	\item Netværkslaget - Fravælges da der kun arbejdes med node-til-node kommunikation.
	\item Datalinklaget - Medtages da datalinklaget er ansvarlig for node-til-node kommunikation
	\item Det fysiske lag - Medtages da der skal overføres data mellem enheder.
\end{itemize}
\section{Problemanalyse}
Der findes en række problemer, indenfor de valgte fokusområder, der skal tages stilling til for at kunne gennemføre projektet.

\begin{itemize}
	\item Transmissionsmediet - Flere enheder deles om et fælles transmissionsmedie, luften, hvilket betyder, at der kan ske en kollision hvis mere end én enhed prøver at sende data på samme tid.
	\item Frekvenser - I projektet er det kun tilladt at bruge DTMF-toner. Dette betyder, der kun er otte frekvenser tilgængelige.
	\item Støj - Hvis der kommer støj på en af de otte frekvenser, kan signalet blive forvrænget, hvilket kan medføre korrupte data.
	\item Signalbehandling - Der skal undersøges den optimale frekvensanalysemetode, til de signaler, der sendes.
	\item Synkronisering - Det er vigtigt at de to enheder, der kommunikerer med hinanden, er synkroniseret. Det vil sige, at modtagerenheden lytter efter toner på de rigtige tidspunkter. Hvis ikke, vil kommunikationen være langt mere sårbar overfor støj.
	\item Fejl kontrol - Da det er valgt at protokollen skal være robust, skal der implementeres en metode til at detektere fejl og kassere fejlbehæftede og duplikerede pakker. Hvis ikke dette gøres vil der leveres forkert data til applikationslaget.
	\item Længden af frames - For at vide hvornår en frame starter og slutter, er det nødvendigt med nogle markører, der kan fortælle modtageren dette. Dette kan f.eks. gøres med felter, med oplysninger om hvor lang framen er, eller med flag i start og slutningen af en frame.
	\item Applikationslaget - Opdeler den data, der skal sendes, i mindre pakker, før de videregives til datalinklaget. Endvidere skal applikationslaget sammensætte de pakker den modtager.
\end{itemize}

\section{Problemformulering}
Hvorledes kan en kommunikationsprotokol designes sådan at, to enheder kan udveksle data, ved brug af lyd, i form af DTMF?

\subsection{Primære problemstillinger}

\begin{itemize}
	\item Hvorledes markeres start og slutning på et stykke data?
	\item Hvorledes kan kollision undgås når begge enheder benytter samme transmissionsmedie?
	\item Hvorledes frasorteres støj, sådan at kun ønskede frekvenser er tilbage?
	\item Hvorledes kontrolleres den transmitterede data for fejl, sådan at al korrupt data bliver kasseret?
\end{itemize}

\subsection{Sekundere problemstillinger}

\begin{itemize}
	\item Hvorledes kan en grafisk brugerflade designes?
	\item Hvorledes kan data sendes mere effektivt?
\end{itemize}

\section{Løsningsforslag}
Problemformuleringen specificerer konkrete problemer, der skal løses i løbet af projektet, for at kunne udarbejde det ønskede produktet. Disse løsningsforslag skal vægtes efter fordele og ulemper og udvælges til brug i produktet.

\subsection{Signalanalyse}
Idet at dataen skal sendes via lyd, og skal virke i et støjfyldt miljø for at have nogen form for praktisk anvendelse, skal signalet behandles, således at eventuel støj kan ignoreres.

\subsubsection{Fast Fourier Transform}
FFT er en metode til at beregne DFT hurtigt og for alle sinuskoefficienter i signalet (op til Nyquist frekvensen). Det er en fællesbetegnelse for alle algoritmer, der beregner DFT i $O(N \log(N))$ tid (for $N$ samples) i forhold til $O(N^2)$ tid, hvis DFT beregnes direkte. Derfor er FFT en betragteligt hurtigere metode til at beregne DFT, hvis man skal bruge koefficienterne for alle sinuserne i signalet.

\subsubsection{Goertzel Algoritmen}
Goertzel algoritmen kan benyttes til at beregne de enkelte DFT koefficienter. Algoritmen er mere effektiv end FFT, hvis mindre end $2 \log(2) \ N$ DFT koefficienter skal beregnes.

Goertzel algoritmen har form som et digitalt filter, og er en kaskade af et IIR-filter(*) og et FIR-filter(*).

\begin{equation}
	s(n)=x(n)+2 \cos(2 \pi f) s(n-1)-s(n-2)
\end{equation}

\begin{equation}
	y(n) = s(n) - e^{-2 \pi i f} s(n-1)
\end{equation}

\subsubsection{Fordele og ulemper}

\begin{table}[h]
	\begin{tabularx}{\textwidth}{|X|X|X|X|}
		\hline
		\multicolumn{2}{|l|}{\textbf{Goertzel}} & \multicolumn{2}{l|}{\textbf{FFT}} \\ \hline
	\textbf{Fordele} & \textbf{Ulemper} & \textbf{Fordele} & \textbf{Ulemper} \\ \hline
	Hurtig ved færre koefficienter & Langsom ved mange koefficienter & Hurtig ved mange koefficienter & Langsom ved få koefficienter \\ \hline
	Simpel implementering& & & Kompliceret implementering\\ \hline
	\end{tabularx}
\end{table}

\subsection{Dupleks}
Da transmissionsmediet ikke understøtter, at mere end én enhed sender med samme frekvenser samtidig, er der tre mulige løsninger: 

\begin{enumerate}
	\item Lav protokollen fuld-dupleks 
	\item Lav protokollen halv-dupleks
	\item Lav protokollen simpleks
\end{enumerate}

Laves protokollen fuld-dupleks kræver det at frekvenserne opdeles (FDMA(*)) således, at hver enhed får tildelt en gruppe af tonerne. Disse grupper må ikke have nogen overlappende frekvenser, da dette ville resultere i, at enhederne forstyrrer hinanden. Derfor får hver enhed 4 ud af de 16 DTMF toner, og hver tone repræsenterer derved to bit.

Benyttes halv-dupleks, er det ikke muligt, at begge enheder transmitterer på samme tid. Dog opnås at hver tone repræsentere fire bit.

Simpleks kasseres, da der ønskes at kunne sende data i begge retninger.

\subsection{Fejlkontrol}
Paritetscheck, CRC(*), SHA og MD5 er fire hyppigt brugte metoder til fejldetektion ved overførsler.

\subsubsection{Paritetsbit}
En paritetsbit angiver om er der et lige eller ulige antal 1’er, der er i en datapakke. Fordelen ved denne type fejlkontrol, er at størrelsen på fejlkontrollen kun er én bit. Ulempen er at denne type fejlkontrol kun kan fange ulige antal fejl i overførslen. Hvis der et lige antal bits der er blevet vendt, så vil paritetschecket hos modtageren ikke opdage fejlene.(*)

\subsubsection{Cyclic Redundancy Check}
CRC laver et antal redundante bit, der bliver påsat en pakke, som skal overføres.  Fordelen ved CRC er, at der kan detekteres single-, dual- og burstfejl.(*) Størrelsen af CRC definerer hvor mange fejl, der kan detekteres, ved kontrol.
Ulempen ved CRC er, at jo større CRC’en er, jo flere redundante bit bliver der påsat datapakken.

\subsubsection{SHA og md5}
Der eksistere utallige biblioteker der indeholder checksum specifikt til validering af filer.

SHA er en checksum der findes i mange forskellige størrelser og som bliver brugt til sikker validering over internettet. En anden checksum er md5sum som ikke længere bliver betragtet som sikkert mod angreb, men som er næsten dobbelt så hurtig som en af de laveste SHA. Risikoen for, at to stykker data giver samme md5sum er $1:2^{128}$.

\subsection{Datalinklagsprotokol}
Tre protokoller bliver taget i betragtning: Stop-and-Wait, Go-Back-N og Selective-Repeat.

\subsubsection{Stop-and-Wait}
Stop-and-Wait protokollen benytter halv-dupleks, og inkorporerer både flow- og fejlkontrol. Fejlkontrol sker i form af en checksum, som bruges til at validere data, mens flowkontrollen foregår ved at pakken først sendes når forrige pakke er blevet kvitteret for.

Protokollen fungerer således at der sendes én pakke ad gangen, hvorefter der ventes på ACK(*). Når pakken sendes startes en timer, som bruges til at gensende pakken, hvis sender ikke har modtaget en ACK inden for en given tidsperiode / tidsrum.

\begin{figure}
	\includegraphics[scale=0.5]{Go-Back-N}
\end{figure}

\subsubsection{Go-back-N}
Go-Back-N protokollen benytter fuld-dupleks.

Protokollen fungerer ved, at der sendes en række pakker i et såkaldt “vindue”. Modtageren sender en ACK med et ACK nummer, når en pakke er modtaget korrekt. ACK nummeret fortæller afsenderen, hvilken pakke der forventes næste gang, og vinduet rykkes. Dette betyder, at en ACK kan gå tabt, uden det påvirker det øvrige flow, idet en senere ACK kvittere for alle foregående pakker. Der kører en timer for den ældste udestående pakke, og når timeren udløber gensendes alle pakkerne i vinduet.

\begin{figure}
	\includegraphics[scale=0.5]{Go-Back-N}
\end{figure}

\subsubsection{Selective-Repeat}
Selective-Repeat protokollen benytter fuld-dupleks.

Protokollen baserer sig ligesom Go-Back-N på vinduer. Der sendes en ACK per pakke som bliver modtaget, som indeholder et ACK nummer. Dette nummer korrespondere med en datapakke, og betyder at den specifikke pakke er blevet modtaget korrekt. Afsenderen har en timer for hver pakke i vinduet, og når den udløber, gensendes kun den enkelte pakke.

\begin{figure}
	\includegraphics[scale=0.5]{Go-Back-N}
\end{figure}

\subsection{Start og slutning på data}
For at fortælle modtageren hvornår en frame starter og slutter, skal der benyttes nogle markører. Der findes to almindelige metoder til at gøre dette:

\subsubsection{Start- og slutflag}
I starten af framen kan der placeres et flag, det vil sige en bestemt rækkefølge af toner. Dette flag markerer starten af en frame. Samtidig kan der ved framens slutning placeres et flag, der markerer at framen slutter.

\subsubsection{Længdefelt}
I framens header kan der laves et felt, der beskriver hvor lang framen er. Dermed ved modtageren at framen er slut når der er modtaget den mængde data, der er beskrevet i feltet.

Der er fordele og ulemper ved de forskellige metoder. Hvis et slutflag benyttes er det nødvendigt at anvende bitstuffing for at undgå at flaget optræder i dataen. Til gengæld er denne metode lettere at implementere på det fysiske lag, da laget ikke skal læse i headeren.

\section{Valg af løsning}
Der skal vælges hvilke løsninger, på ovenstående problemstillinger, der implementeres.
Der skal bruges en metode til signalanalyse. Her vælges Goertzel algoritmen.
Denne vælges da amplituden kun skal bruges ved otte forskellige frekvenser. Derfor vil det være hurtigere at benytte Goertzel hvis der arbejdes på mere end $(n=2^(x/2)=2^(8/2)=16)$ samples.

Det skal vælges, om der skal benyttes halv- eller fuld-dupleks.
Fuld-dupleks er optimalt hvis der f.eks. ønskes at lave en chat applikation, da begge enheder ville være istand til at sende deres beskeder uden at vente på hinanden. Men da der ønskes at lave en fildelingsapplikation, hvor den ene enhed skal sende mere data end den anden, er det blevet valgt at halv-dupleks skal benyttes, da det vurderes at der dermed kan opnås den højeste overførselshastighed.

Det skal sikres at der ikke slipper korrupte datapakker igennem til applikationslaget. 
Til fejlkontrol vælges der to forskellige metoder. CRC til datalinklaget, og en md5sum på applikationslaget. På datalinklaget vælges der CRC grundet mængden af fejl CRC kan detektere.
md5summen vælges på applikationslaget for at have en ekstra kontrol hvis det skulle ske at en fejl kommer igennem på datalinklaget. 

Til at markere starten og slutningen af en pakke vælges der et start- og slutflag, da det gør det fysiske lag betydeligt simplere.

Det sidste der skal besluttes, er hvilken protokol der skal bruges til overførslen. Baseret på det foregående valg, med at benytte halv-dupleks, er det kun Stop-and-Wait protokollen der er tilbage. Derfor er denne valgt.

\section{Produkt}
Udfra ovenstående valg, bliver produktet halv-dupleks, med en Stop-and-Wait-baseret protokol. For at sikre imod korrupt data, er der samtidig valgt fejlkontrol på både datalink- og applikationslaget.

Der er udviklet 3 lag til produktet: 

\begin{enumerate}
	\item Et fysisk lag der står for kommunikationen mellem to enheder (ikke pålidelig(*))
	\item Et datalinklag der står for nummerering af pakkerne, håndtering af forbindelsen samt
	fejlkontrol (pålidelig)
	\item Et applikationslag der står for håndteringen af filoverførslen og funktionalitet, der benyttes 
\end{enumerate}

Programmet er opbygget således, at hvert lag er en klasse(*) for sig selv. I hver klasse kører der nogle tråde(*), der tager sig af indgående og udgående data på de forskellige lag. Opbygningen i tråde gør det muligt at undgå, at de forskellige lag blokerer for hinanden, og de kan derfor arbejde uden at vente på hinanden. Kommunikationen mellem de forskellige lag foregår ved hjælp af buffere.

Lagene er opbygget i klasser, da det gør det lettere at isolere funktionaliteten i de forskellige lag i separate komponenter, der kan udvikles og fejlrettes individuelt og uafhængigt af hinanden. Samtidig betyder det, at det er let at udskifte et lag med et andet.
 
Datalinklaget og det fysiske lag har følgende offentlige metoder, der benyttes af de øvre lag:

\begin{table}[h]
	\begin{tabularx}{\textwidth}{|X|X||}
		
	\end{tabularx}
\end{table}

\section{Det fysiske lag}

\subsection{Sendertråden}

\subsubsection{Afspiller}

\subsection{Modtagertråden}

\subsubsection{Optager}

\subsubsection{Synkronisering}

\subsubsection{Detektion af DTMF-Toner}

\subsection{Fast Fourier Transform}

\subsection{Goertzel algoritmen}

\section{Datalinklaget}

\subsection{Stop-and-Wait protokol}

\subsection{Fejl detektering}

\subsection{Type}

\subsection{Kontrol af ID}

\subsection{Bitstuffing}

\subsection{Padding}

\subsection{Transmitter tråden}

\subsection{Receiver tråden}

\section{Applikationslaget}

\subsection{Funktioner}

\subsubsection{sendFile}

\subsubsection{requestFile}

\subsubsection{sendFileTree}

\subsubsection{requestFileTree}

\subsubsection{makeFolder}

\subsubsection{deleteFile/deleteFolder}

\subsection{Flag/Type}

\subsubsection{Finale}

\subsubsection{Size}

\subsubsection{Name}

\subsubsection{Data}

\subsubsection{Request File}

\subsubsection{Delete File}

\subsubsection{Message}

\subsubsection{File Tree Request}

\subsubsection{Make Folder}

\subsubsection{md5 Hash}

\subsubsection{Requested Compressed File}

\subsubsection{File Tree}

\subsection{Receiver tråden}

\subsubsection{Biblioteker}

\subsection{Fejl detektering}

\subsection{CLI}

\subsection{Grafisk brugerflade}

\subsubsection{Progress baren}

\subsubsection{Send File}

\subsubsection{Request File}

\subsubsection{QT}

\section{Software udvikling}

\section{Diskussion}

\section{Konklusion}

hallo

\section{Ordliste}

\begin{itemize*}


\item \textbf{PWM} - Puls bredde modulation se afsnit 9.2
\end{itemize*}

\section{Litteraturliste}
\begingroup
\renewcommand{\section}[2]{}
\begin{thebibliography}{9}


\bibitem{bluetooth}
RN-42 \\
Datablad: \\
https://www.sparkfun.com/datasheets/Wireless/Bluetooth/rn-42-ds.pdf


\end{thebibliography}
\endgroup
\section{Bilag}

\subsection*{Bilagsfortegnelse}

Herunder ses en oversigt over de vedlagte bilag.
Alle findes på den vedlagte DVD.

\begin{description*}
\item[Bilag 1] Printdiagram


\item[Bilag 2] Tidsplan

    
\item[Bilag 3] Projektoplæg (Kun DVD)


\item[Bilag 4] Kode (Kun DVD)

    
\item[Bilag 5] Rapport (Kun DVD)


\end{description*}

\newpage
\subsection*{Bilag 1}


\newpage
\subsection*{Bilag 2}


\newpage
\subsection*{Bilag 3}


\end{document}